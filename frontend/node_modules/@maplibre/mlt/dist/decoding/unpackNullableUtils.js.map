{"version":3,"file":"unpackNullableUtils.js","sourceRoot":"","sources":["../../src/decoding/unpackNullableUtils.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,6BAA6B,CAAC;AAapD;;;;;;;;GAQG;AACH,MAAM,UAAU,cAAc,CAC1B,UAAa,EACb,WAA6B,EAC7B,YAA6B;IAE7B,8CAA8C;IAC9C,IAAI,CAAC,WAAW,EAAE,CAAC;QACf,OAAO,UAAU,CAAC;IACtB,CAAC;IAED,MAAM,IAAI,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;IAChC,+CAA+C;IAC/C,MAAM,WAAW,GAAG,UAAU,CAAC,WAAoC,CAAC;IACpE,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,IAAI,CAAM,CAAC;IAE1C,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,wEAAwE;QACxE,MAAM,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAE,YAAoB,CAAC;IACnF,CAAC;IAED,OAAO,MAAM,CAAC;AAClB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CACjC,UAAsB,EACtB,cAAsB,EACtB,WAA6B;IAE7B,oBAAoB;IACpB,IAAI,CAAC,WAAW,EAAE,CAAC;QACf,OAAO,UAAU,CAAC;IACtB,CAAC;IAED,MAAM,WAAW,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;IACvC,MAAM,SAAS,GAAG,IAAI,SAAS,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IAC5D,MAAM,MAAM,GAAG,IAAI,SAAS,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;IAEtF,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE,CAAC;QACnC,sEAAsE;QACtE,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACpE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACzB,CAAC;IAED,OAAO,MAAM,CAAC,SAAS,EAAE,CAAC;AAC9B,CAAC","sourcesContent":["import BitVector from \"../vector/flat/bitVector.js\";\n\n/**\n * Type constraint for TypedArray types that can be unpacked\n */\nexport type TypedArrayConstructor =\n    | Int32ArrayConstructor\n    | BigInt64ArrayConstructor\n    | Float32ArrayConstructor\n    | Float64ArrayConstructor;\n\nexport type TypedArrayInstance = Int32Array | BigInt64Array | Float32Array | Float64Array;\n\n/**\n * Generic unpacking function.\n * Reconstructs the full array by inserting default values at null positions.\n *\n * @param dataStream The compact data stream containing only non-null values\n * @param presentBits BitVector indicating which positions have values (null if non-nullable)\n * @param defaultValue The default value to insert at null positions (0, 0n, etc.)\n * @returns Full array with default values at null positions\n */\nexport function unpackNullable<T extends TypedArrayInstance>(\n    dataStream: T,\n    presentBits: BitVector | null,\n    defaultValue: number | bigint,\n): T {\n    // Non-nullable case: return data stream as-is\n    if (!presentBits) {\n        return dataStream;\n    }\n\n    const size = presentBits.size();\n    // Create new array of same type with full size\n    const constructor = dataStream.constructor as TypedArrayConstructor;\n    const result = new constructor(size) as T;\n\n    let counter = 0;\n    for (let i = 0; i < size; i++) {\n        // If position has a value, take from data stream; otherwise use default\n        result[i] = presentBits.get(i) ? dataStream[counter++] : (defaultValue as any);\n    }\n\n    return result;\n}\n\n/**\n * Special case for boolean columns because BitVector is not directly compatible with TypedArray.\n *\n * @param dataStream The compact BitVector data containing only non-null boolean values\n * @param dataStreamSize The number of actual values in dataStream\n * @param presentBits BitVector indicating which positions have values (null if non-nullable)\n * @returns Uint8Array buffer for BitVector with false at null positions\n */\nexport function unpackNullableBoolean(\n    dataStream: Uint8Array,\n    dataStreamSize: number,\n    presentBits: BitVector | null,\n): Uint8Array {\n    // Non-nullable case\n    if (!presentBits) {\n        return dataStream;\n    }\n\n    const numFeatures = presentBits.size();\n    const bitVector = new BitVector(dataStream, dataStreamSize);\n    const result = new BitVector(new Uint8Array(Math.ceil(numFeatures / 8)), numFeatures);\n\n    let counter = 0;\n    for (let i = 0; i < numFeatures; i++) {\n        // If position has a value, take from data stream; otherwise use false\n        const value = presentBits.get(i) ? bitVector.get(counter++) : false;\n        result.set(i, value);\n    }\n\n    return result.getBuffer();\n}\n"]}