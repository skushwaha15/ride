{"version":3,"file":"integerStreamDecoder.js","sourceRoot":"","sources":["../../src/decoding/integerStreamDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { PhysicalLevelTechnique } from \"../metadata/tile/physicalLevelTechnique\";\nimport type IntWrapper from \"./intWrapper\";\nimport {\n    decodeComponentwiseDeltaVec2,\n    decodeComponentwiseDeltaVec2Scaled,\n    decodeDeltaRleInt32,\n    decodeDeltaRleInt64,\n    decodeFastPfor,\n    decodeUnsignedConstRleInt32,\n    decodeUnsignedConstRleInt64,\n    decodeUnsignedRleInt32,\n    decodeUnsignedRleInt64,\n    decodeUnsignedRleFloat64,\n    decodeVarintInt32,\n    decodeVarintInt64,\n    decodeVarintFloat64,\n    decodeZigZagInt32,\n    decodeZigZagInt64,\n    decodeZigZagFloat64,\n    decodeZigZagConstRleInt32,\n    decodeZigZagConstRleInt64,\n    decodeZigZagDeltaInt32,\n    decodeZigZagDeltaInt64,\n    decodeZigZagDeltaFloat64,\n    decodeZigZagSequenceRleInt32,\n    decodeZigZagSequenceRleInt64,\n    decodeZigZagInt32Value,\n    decodeZigZagInt64Value,\n    fastInverseDelta,\n    inverseDelta,\n    decodeRleDeltaInt32,\n    decodeZigZagDeltaOfDeltaInt32,\n    decodeZigZagRleDeltaInt32,\n    decodeZigZagRleInt32,\n    decodeZigZagRleInt64,\n    decodeZigZagRleFloat64,\n} from \"./integerDecodingUtils\";\nimport { LogicalLevelTechnique } from \"../metadata/tile/logicalLevelTechnique\";\nimport { type StreamMetadata, type RleEncodedStreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport BitVector from \"../vector/flat/bitVector\";\nimport { VectorType } from \"../vector/vectorType\";\nimport type GeometryScaling from \"./geometryScaling\";\nimport { unpackNullable } from \"./unpackNullableUtils\";\n\nexport function decodeIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    scalingData?: GeometryScaling,\n    nullabilityBuffer?: BitVector,\n): Int32Array {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeInt32(values, streamMetadata, isSigned, scalingData, nullabilityBuffer);\n}\n\nexport function decodeLengthStreamToOffsetBuffer(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): Uint32Array {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeLengthToOffsetBuffer(values, streamMetadata);\n}\n\nfunction decodePhysicalLevelTechnique(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): Int32Array {\n    const physicalLevelTechnique = streamMetadata.physicalLevelTechnique;\n    if (physicalLevelTechnique === PhysicalLevelTechnique.FAST_PFOR) {\n        return decodeFastPfor(data, streamMetadata.numValues, streamMetadata.byteLength, offset);\n    }\n    if (physicalLevelTechnique === PhysicalLevelTechnique.VARINT) {\n        return decodeVarintInt32(data, offset, streamMetadata.numValues);\n    }\n\n    if (physicalLevelTechnique === PhysicalLevelTechnique.NONE) {\n        const dataOffset = offset.get();\n        const byteLength = streamMetadata.byteLength;\n        offset.add(byteLength);\n        //TODO: use Byte Rle for geometry type encoding\n        const slice = data.subarray(dataOffset, offset.get());\n        return new Int32Array(slice);\n    }\n\n    throw new Error(\"Specified physicalLevelTechnique is not supported (yet).\");\n}\n\nexport function decodeConstIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): number {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n\n    if (values.length === 1) {\n        const value = values[0];\n        return isSigned ? decodeZigZagInt32Value(value) : value;\n    }\n\n    return isSigned ? decodeZigZagConstRleInt32(values) : decodeUnsignedConstRleInt32(values);\n}\n\nexport function decodeSequenceIntStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): [baseValue: number, delta: number] {\n    const values = decodePhysicalLevelTechnique(data, offset, streamMetadata);\n    return decodeZigZagSequenceRleInt32(values);\n}\n\nexport function decodeSequenceLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n): [baseValue: bigint, delta: bigint] {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n    return decodeZigZagSequenceRleInt64(values);\n}\n\nexport function decodeLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    nullabilityBuffer?: BitVector,\n): BigInt64Array {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n    return decodeInt64(values, streamMetadata, isSigned, nullabilityBuffer);\n}\n\nexport function decodeLongFloat64Stream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): Float64Array {\n    const values = decodeVarintFloat64(data, offset, streamMetadata.numValues);\n    return decodeFloat64(values, streamMetadata, isSigned);\n}\n\nexport function decodeConstLongStream(\n    data: Uint8Array,\n    offset: IntWrapper,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n): bigint {\n    const values = decodeVarintInt64(data, offset, streamMetadata.numValues);\n\n    if (values.length === 1) {\n        const value = values[0];\n        return isSigned ? decodeZigZagInt64Value(value) : value;\n    }\n\n    return isSigned ? decodeZigZagConstRleInt64(values) : decodeUnsignedConstRleInt64(values);\n}\n\n/**\n * This method decodes integer streams.\n * Currently the encoder uses only fixed combinations of encodings.\n * For performance reasons it is also uses a fixed combination of the encodings on the decoding side.\n * The following encodings and combinations are used:\n *   - Morton Delta -> always sorted so not ZigZag encoding needed\n *   - Delta -> currently always in combination with ZigZag encoding\n *   - Rle -> in combination with ZigZag encoding if data type is signed\n *   - Delta Rle\n *   - Componentwise Delta -> always ZigZag encoding is used\n */\nfunction decodeInt32(\n    values: Int32Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    scalingData?: GeometryScaling,\n    nullabilityBuffer?: BitVector,\n): Int32Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                if (!nullabilityBuffer) {\n                    return decodeDeltaRleInt32(values, rleMetadata.runs, rleMetadata.numRleValues);\n                }\n                values = decodeUnsignedRleInt32(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDeltaInt32(values);\n            break;\n        case LogicalLevelTechnique.RLE:\n            values = decodeRleInt32(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n            break;\n        case LogicalLevelTechnique.MORTON:\n            fastInverseDelta(values);\n            break;\n        case LogicalLevelTechnique.COMPONENTWISE_DELTA:\n            if (scalingData && !nullabilityBuffer) {\n                decodeComponentwiseDeltaVec2Scaled(values, scalingData.scale, scalingData.min, scalingData.max);\n                return values;\n            }\n            decodeComponentwiseDeltaVec2(values);\n            break;\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZagInt32(values);\n            }\n            break;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n\n    if (nullabilityBuffer) {\n        return unpackNullable(values, nullabilityBuffer, 0);\n    }\n    return values;\n}\n\nfunction decodeInt64(\n    values: BigInt64Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    nullabilityBuffer?: BitVector,\n): BigInt64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                if (!nullabilityBuffer) {\n                    return decodeDeltaRleInt64(values, rleMetadata.runs, rleMetadata.numRleValues);\n                }\n                values = decodeUnsignedRleInt64(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDeltaInt64(values);\n            break;\n        case LogicalLevelTechnique.RLE:\n            values = decodeRleInt64(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n            break;\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZagInt64(values);\n            }\n            break;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n\n    if (nullabilityBuffer) {\n        return unpackNullable(values, nullabilityBuffer, 0n);\n    }\n    return values;\n}\n\nexport function decodeFloat64(values: Float64Array, streamMetadata: StreamMetadata, isSigned: boolean): Float64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n                values = decodeUnsignedRleFloat64(values, rleMetadata.runs, rleMetadata.numRleValues);\n            }\n            decodeZigZagDeltaFloat64(values);\n            return values;\n        case LogicalLevelTechnique.RLE:\n            return decodeRleFloat64(values, streamMetadata as RleEncodedStreamMetadata, isSigned);\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                decodeZigZagFloat64(values);\n            }\n            return values;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nfunction decodeLengthToOffsetBuffer(values: Int32Array, streamMetadata: StreamMetadata): Uint32Array {\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.DELTA &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        return decodeZigZagDeltaOfDeltaInt32(values);\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.RLE &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n        return decodeRleDeltaInt32(values, rleMetadata.runs, rleMetadata.numRleValues);\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.NONE &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.NONE\n    ) {\n        //TODO: use fastInverseDelta again and check what are the performance problems in zoom 14\n        //fastInverseDelta(values);\n        inverseDelta(values);\n        const offsets = new Uint32Array(streamMetadata.numValues + 1);\n        offsets[0] = 0;\n        offsets.set(values, 1);\n        return offsets;\n    }\n\n    if (\n        streamMetadata.logicalLevelTechnique1 === LogicalLevelTechnique.DELTA &&\n        streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE\n    ) {\n        const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n        const decodedValues = decodeZigZagRleDeltaInt32(values, rleMetadata.runs, rleMetadata.numRleValues);\n        fastInverseDelta(decodedValues);\n        return decodedValues;\n    }\n\n    throw new Error(\"Only delta encoding is supported for transforming length to offset streams yet.\");\n}\n\nexport function getVectorType(\n    streamMetadata: StreamMetadata,\n    sizeOrNullabilityBuffer: number | BitVector,\n    data: Uint8Array,\n    offset: IntWrapper,\n): VectorType {\n    const logicalLevelTechnique1 = streamMetadata.logicalLevelTechnique1;\n    if (logicalLevelTechnique1 === LogicalLevelTechnique.RLE) {\n        return (streamMetadata as RleEncodedStreamMetadata).runs === 1 ? VectorType.CONST : VectorType.FLAT;\n    }\n\n    if (\n        logicalLevelTechnique1 !== LogicalLevelTechnique.DELTA ||\n        streamMetadata.logicalLevelTechnique2 !== LogicalLevelTechnique.RLE\n    ) {\n        return streamMetadata.numValues === 1 ? VectorType.CONST : VectorType.FLAT;\n    }\n    const numFeatures =\n        sizeOrNullabilityBuffer instanceof BitVector ? sizeOrNullabilityBuffer.size() : sizeOrNullabilityBuffer;\n    const rleMetadata = streamMetadata as RleEncodedStreamMetadata;\n\n    if (rleMetadata.numRleValues !== numFeatures) {\n        return VectorType.FLAT;\n    }\n    // Single run is always a sequence\n    if (rleMetadata.runs === 1) {\n        return VectorType.SEQUENCE;\n    }\n\n    if (rleMetadata.runs !== 2) {\n        return streamMetadata.numValues === 1 ? VectorType.CONST : VectorType.FLAT;\n    }\n    // Two runs can be a sequence if both deltas are equal to 1\n    const savedOffset = offset.get();\n\n    let values: Int32Array;\n    if (streamMetadata.physicalLevelTechnique === PhysicalLevelTechnique.VARINT) {\n        values = decodeVarintInt32(data, offset, 4);\n    } else {\n        const byteOffset = offset.get();\n        values = new Int32Array(data.buffer, data.byteOffset + byteOffset, 4);\n    }\n    offset.set(savedOffset);\n    // Check if both deltas are encoded 1\n    const zigZagOne = 2;\n    if (values[2] === zigZagOne && values[3] === zigZagOne) {\n        return VectorType.SEQUENCE;\n    }\n    return streamMetadata.numValues === 1 ? VectorType.CONST : VectorType.FLAT;\n}\n\nfunction decodeRleInt32(data: Int32Array, streamMetadata: RleEncodedStreamMetadata, isSigned: boolean): Int32Array {\n    return isSigned\n        ? decodeZigZagRleInt32(data, streamMetadata.runs, streamMetadata.numRleValues)\n        : decodeUnsignedRleInt32(data, streamMetadata.runs, streamMetadata.numRleValues);\n}\n\nfunction decodeRleInt64(\n    data: BigInt64Array,\n    streamMetadata: RleEncodedStreamMetadata,\n    isSigned: boolean,\n): BigInt64Array {\n    return isSigned\n        ? decodeZigZagRleInt64(data, streamMetadata.runs, streamMetadata.numRleValues)\n        : decodeUnsignedRleInt64(data, streamMetadata.runs, streamMetadata.numRleValues);\n}\n\nfunction decodeRleFloat64(\n    data: Float64Array,\n    streamMetadata: RleEncodedStreamMetadata,\n    isSigned: boolean,\n): Float64Array {\n    return isSigned\n        ? decodeZigZagRleFloat64(data, streamMetadata.runs, streamMetadata.numRleValues)\n        : decodeUnsignedRleFloat64(data, streamMetadata.runs, streamMetadata.numRleValues);\n}\n"]}