{"version":3,"file":"stringDecoder.spec.js","sourceRoot":"","sources":["../../src/decoding/stringDecoder.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect } from \"vitest\";\nimport IntWrapper from \"./intWrapper\";\nimport { decodeString, decodeSharedDictionary } from \"./stringDecoder\";\nimport { encodePlainStrings, encodeDictionaryStrings } from \"../encoding/stringEncoder\";\nimport {\n    concatenateBuffers,\n    createColumnMetadataForStruct,\n    createStream,\n    encodeFsstStrings,\n    encodeSharedDictionary,\n    encodeStructField,\n} from \"./decodingTestUtils\";\nimport { StringFlatVector } from \"../vector/flat/stringFlatVector\";\nimport { StringDictionaryVector } from \"../vector/dictionary/stringDictionaryVector\";\nimport { StringFsstDictionaryVector } from \"../vector/fsst-dictionary/stringFsstDictionaryVector\";\nimport { ScalarType } from \"../metadata/tileset/tilesetMetadata\";\nimport { PhysicalStreamType } from \"../metadata/tile/physicalStreamType\";\nimport { LengthType } from \"../metadata/tile/lengthType\";\nimport { LogicalStreamType } from \"../metadata/tile/logicalStreamType\";\n\ndescribe(\"decodeString - Plain String Decoder\", () => {\n    it(\"should decode plain strings with simple ASCII values\", () => {\n        const expectedStrings = [\"hello\", \"world\", \"test\"];\n        const encodedStrings = encodePlainStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        expect(result).toBeInstanceOf(StringFlatVector);\n        const resultVec = result as StringFlatVector;\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode plain strings with varying lengths\", () => {\n        const expectedStrings = [\"a\", \"abc\", \"hello world\"];\n        const encodedStrings = encodePlainStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        const resultVec = result as StringFlatVector;\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode plain strings with empty strings\", () => {\n        const expectedStrings = [\"\", \"encodedStrings\", \"\", \"more\"];\n        const encodedStrings = encodePlainStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        expect(result).toBeInstanceOf(StringFlatVector);\n        const resultVec = result as StringFlatVector;\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode mixed null and empty strings\", () => {\n        const expectedStrings = [null, \"\", \"encodedStrings\", null, \"\"];\n        const encodedStrings = encodePlainStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).not.toBeNull();\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(result.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode mixed ASCII and UTF-8 strings\", () => {\n        const expectedStrings = [\"hello\", \"Привет\", \"world\", \"日本\"];\n        const encodedStrings = encodePlainStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        expect(result).toBeInstanceOf(StringFlatVector);\n        const resultVec = result as StringFlatVector;\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n});\n\ndescribe(\"decodeString - Dictionary String Decoder\", () => {\n    it(\"should decode dictionary-compressed strings with repeated values\", () => {\n        const expectedStrings = [\"cat\", \"dog\", \"cat\", \"cat\", \"dog\"];\n        const encodedStrings = encodeDictionaryStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).toBeInstanceOf(StringDictionaryVector);\n        const resultVec = result as StringDictionaryVector;\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode dictionary with single repeated string\", () => {\n        const expectedStrings = [\"same\", \"same\", \"same\"];\n        const encodedStrings = encodeDictionaryStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).toBeInstanceOf(StringDictionaryVector);\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(result.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode dictionary with UTF-8 strings\", () => {\n        const expectedStrings = [\"café\", \"日本\", \"café\", \"日本\"];\n        const encodedStrings = encodeDictionaryStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).toBeInstanceOf(StringDictionaryVector);\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(result.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode dictionary with all unique strings\", () => {\n        const expectedStrings = [\"unique1\", \"unique2\", \"unique3\", \"unique4\"];\n        const encodedStrings = encodeDictionaryStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).toBeInstanceOf(StringDictionaryVector);\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(result.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n\n    it(\"should decode nullable dictionary strings\", () => {\n        const expectedStrings = [null, \"\", \"encodedStrings\", \"\", null];\n        const encodedStrings = encodeDictionaryStrings(expectedStrings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 4);\n\n        expect(result).toBeInstanceOf(StringDictionaryVector);\n        for (let i = 0; i < expectedStrings.length; i++) {\n            expect(result.getValue(i)).toBe(expectedStrings[i]);\n        }\n    });\n});\n\ndescribe(\"decodeString - FSST Dictionary Decoder (Basic Coverage)\", () => {\n    it(\"should decode FSST-compressed strings with simple symbol table\", () => {\n        const encodedStrings = encodeFsstStrings();\n        const offset = new IntWrapper(0);\n\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 6);\n\n        expect(result).toBeInstanceOf(StringFsstDictionaryVector);\n        const resultVec = result as StringFsstDictionaryVector;\n\n        const expectedValues = [\"cat\", \"dog\", \"cat\"];\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n});\n\ndescribe(\"decodeString - Empty Column Edge Cases\", () => {\n    it(\"should handle empty column with numStreams = 0 (returns null)\", () => {\n        const fullStream = new Uint8Array([]);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", fullStream, offset, 0);\n        expect(result).toBeNull();\n    });\n\n    it(\"should handle column with all zero-length streams (returns null)\", () => {\n        const emptyStream = createStream(PhysicalStreamType.LENGTH, new Uint8Array([]), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.VAR_BINARY),\n        });\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", emptyStream, offset, 1);\n        expect(result).toBeNull();\n    });\n\n    it(\"should handle single value plain string column\", () => {\n        const strings = [\"single\"];\n        const encodedStrings = encodePlainStrings(strings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        expect(result).toBeInstanceOf(StringFlatVector);\n        expect((result as StringFlatVector).getValue(0)).toBe(\"single\");\n    });\n\n    it(\"should handle single null value in plain string column (returns null)\", () => {\n        const strings = [null];\n        const encodedStrings = encodePlainStrings(strings);\n        const offset = new IntWrapper(0);\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n        expect(result).toBeNull();\n    });\n});\n\ndescribe(\"decodeString - Integration Tests\", () => {\n    it(\"should correctly track offset through multiple streams\", () => {\n        const strings = [\"hello\", \"world\"];\n        const encodedStrings = encodePlainStrings(strings);\n        const offset = new IntWrapper(0);\n        const initialOffset = offset.get();\n\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 2);\n\n        expect(result).toBeInstanceOf(StringFlatVector);\n        expect(offset.get()).toBeGreaterThan(initialOffset);\n        expect(offset.get()).toBe(encodedStrings.length);\n    });\n\n    it(\"should correctly track offset through nullable streams\", () => {\n        const strings = [\"test\", null, \"encodedStrings\"];\n        const encodedStrings = encodePlainStrings(strings);\n        const offset = new IntWrapper(0);\n        const initialOffset = offset.get();\n\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 3);\n\n        expect(result).not.toBeNull();\n        expect(offset.get()).toBeGreaterThan(initialOffset);\n        expect(offset.get()).toBe(encodedStrings.length);\n    });\n\n    it(\"should correctly track offset through FSST dictionary streams\", () => {\n        const encodedStrings = encodeFsstStrings();\n        const offset = new IntWrapper(0);\n        const initialOffset = offset.get();\n\n        const result = decodeString(\"testColumn\", encodedStrings, offset, 6);\n\n        expect(result).toBeInstanceOf(StringFsstDictionaryVector);\n        expect(offset.get()).toBeGreaterThan(initialOffset);\n        expect(offset.get()).toBe(encodedStrings.length);\n    });\n\n    it(\"should handle consecutive decoding operations with shared offset tracker\", () => {\n        const stream1 = encodePlainStrings([\"first\"]);\n        const stream2 = encodePlainStrings([\"second\"]);\n        const combinedStream = concatenateBuffers(stream1, stream2);\n\n        const offset = new IntWrapper(0);\n\n        const result1 = decodeString(\"column1\", combinedStream, offset, 2);\n        expect((result1 as StringFlatVector).getValue(0)).toBe(\"first\");\n\n        const offsetAfterFirst = offset.get();\n\n        const result2 = decodeString(\"column2\", combinedStream, offset, 2);\n        expect((result2 as StringFlatVector).getValue(0)).toBe(\"second\");\n\n        expect(offset.get()).toBeGreaterThan(offsetAfterFirst);\n        expect(offset.get()).toBe(combinedStream.length);\n    });\n});\n\ndescribe(\"decodeSharedDictionary\", () => {\n    describe(\"basic functionality\", () => {\n        it(\"should decode single field with shared dictionary\", () => {\n            const dictionaryStrings = [\"apple\", \"banana\", \"peach\", \"date\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const fieldStreams = encodeStructField([0, 1, 2, 3], [true, true, true, true]);\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"address:\", [{ name: \"street\" }]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                4,\n            );\n\n            expect(result).toHaveLength(1);\n            expect(result[0]).toBeInstanceOf(StringDictionaryVector);\n            expect(result[0].name).toBe(\"address:street\");\n            for (let i = 0; i < dictionaryStrings.length; i++) {\n                expect(result[0].getValue(i)).toBe(dictionaryStrings[i]);\n            }\n        });\n\n        it(\"should handle empty child field name (common prefix stripped)\", () => {\n            const dictionaryStrings = [\"Berlin\", \"London\", \"Paris\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const fieldStreams = encodeStructField([0, 1, 2], [true, true, true]);\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"name\", [{ name: \"\" }]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                3,\n            );\n\n            expect(result).toHaveLength(1);\n            expect(result[0].name).toBe(\"name\");\n            for (let i = 0; i < dictionaryStrings.length; i++) {\n                expect(result[0].getValue(i)).toBe(dictionaryStrings[i]);\n            }\n        });\n\n        it(\"should handle mix of empty and delimited child names\", () => {\n            const dict = [\"value1\", \"value2\", \"value3\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dict);\n\n            const field1 = encodeStructField([0], [true]);\n            const field2 = encodeStructField([1], [true]);\n            const field3 = encodeStructField([2], [true]);\n\n            const complete = concatenateBuffers(lengthStream, dataStream, field1, field2, field3);\n            const metadata = createColumnMetadataForStruct(\"name\", [\n                { name: \"\" },\n                { name: \":en\" },\n                { name: \":de\" },\n            ]);\n\n            const result = decodeSharedDictionary(complete, new IntWrapper(0), metadata, 1);\n\n            expect(result).toHaveLength(3);\n            expect(result[0].name).toBe(\"name\");\n            expect(result[1].name).toBe(\"name:en\");\n            expect(result[2].name).toBe(\"name:de\");\n        });\n    });\n\n    describe(\"nullability\", () => {\n        it(\"should handle nullable fields with PRESENT stream\", () => {\n            const dictionaryStrings = [\"red\", \"green\", \"blue\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const fieldStreams = encodeStructField([0, 2], [true, false, true, false]);\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"colors:\", [{ name: \"primary\" }]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                4,\n            );\n\n            expect(result).toHaveLength(1);\n            const expected = [\"red\", null, \"blue\", null];\n            for (let i = 0; i < expected.length; i++) {\n                expect(result[0].getValue(i)).toBe(expected[i]);\n            }\n        });\n\n        it(\"should detect nullable fields when offsetCount < numFeatures\", () => {\n            const dictionaryStrings = [\"alpha\", \"beta\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            // Simulating implicit nullability by mismatched counts\n            const fieldStreams = encodeStructField([0, 1], [true, false, false, true]);\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"greek:\", [{ name: \"letter\" }]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                4,\n            );\n\n            expect(result).toHaveLength(1);\n            const expected = [\"alpha\", null, null, \"beta\"];\n            for (let i = 0; i < expected.length; i++) {\n                expect(result[0].getValue(i)).toBe(expected[i]);\n            }\n        });\n    });\n\n    describe(\"FSST encoding\", () => {\n        it(\"should decode FSST-compressed shared dictionary\", () => {\n            const dictionaryStrings = [\"compressed1\", \"compressed2\"];\n            const { lengthStream, dataStream, symbolLengthStream, symbolDataStream } = encodeSharedDictionary(\n                dictionaryStrings,\n                { useFsst: true },\n            );\n\n            const fieldStreams = encodeStructField([0, 1], [true, true]);\n            const completeencodedStrings = concatenateBuffers(\n                lengthStream,\n                symbolLengthStream,\n                symbolDataStream,\n                dataStream,\n                fieldStreams,\n            );\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"encodedStrings:\", [{ name: \"value\" }]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                2,\n            );\n\n            expect(result).toHaveLength(1);\n            expect(result[0]).toBeInstanceOf(StringFsstDictionaryVector);\n            expect(result[0].name).toBe(\"encodedStrings:value\");\n        });\n    });\n\n    describe(\"field filtering\", () => {\n        it(\"should filter fields by propertyColumnNames\", () => {\n            const dictionaryStrings = [\"val1\", \"val2\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const field1Streams = encodeStructField([0], [true]);\n            const field2Streams = encodeStructField([1], [true]);\n            const field3Streams = encodeStructField([0], [true]);\n\n            const completeencodedStrings = concatenateBuffers(\n                lengthStream,\n                dataStream,\n                field1Streams,\n                field2Streams,\n                field3Streams,\n            );\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"multi:\", [\n                { name: \"field1\" },\n                { name: \"field2\" },\n                { name: \"field3\" },\n            ]);\n\n            const propertyColumnNames = new Set([\"multi:field1\", \"multi:field3\"]);\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                1,\n                propertyColumnNames,\n            );\n\n            expect(result).toHaveLength(2);\n            expect(result[0].name).toBe(\"multi:field1\");\n            expect(result[1].name).toBe(\"multi:field3\");\n        });\n\n        it(\"should skip fields with numStreams=0\", () => {\n            const dictionaryStrings = [\"present\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const field1Streams = encodeStructField([0], [true], true);\n            const field2Streams = encodeStructField([], [], false); // numStreams=0\n            const field3Streams = encodeStructField([0], [true], true);\n\n            const completeencodedStrings = concatenateBuffers(\n                lengthStream,\n                dataStream,\n                field1Streams,\n                field2Streams,\n                field3Streams,\n            );\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"test:\", [\n                { name: \"field1\" },\n                { name: \"field2\" },\n                { name: \"field3\" },\n            ]);\n\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                1,\n            );\n\n            expect(result).toHaveLength(2);\n            expect(result[0].name).toBe(\"test:field1\");\n            expect(result[1].name).toBe(\"test:field3\");\n        });\n\n        it(\"should handle mixed present and filtered fields\", () => {\n            const dictionaryStrings = [\"encodedStrings\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const field1Streams = encodeStructField([0], [true], true);\n            const field2Streams = encodeStructField([], [], false);\n            const field3Streams = encodeStructField([0], [true], true);\n\n            const completeencodedStrings = concatenateBuffers(\n                lengthStream,\n                dataStream,\n                field1Streams,\n                field2Streams,\n                field3Streams,\n            );\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"mixed:\", [\n                { name: \"field1\" },\n                { name: \"field2\" },\n                { name: \"field3\" },\n            ]);\n\n            const propertyColumnNames = new Set([\"mixed:field3\"]);\n            const result = decodeSharedDictionary(\n                completeencodedStrings,\n                new IntWrapper(0),\n                columnMetaencodedStrings,\n                1,\n                propertyColumnNames,\n            );\n\n            expect(result).toHaveLength(1);\n            expect(result[0].name).toBe(\"mixed:field3\");\n        });\n    });\n\n    describe(\"error handling\", () => {\n        it(\"should throw error for non-string field types\", () => {\n            const dictionaryStrings = [\"value\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n            const fieldStreams = encodeStructField([0], [true]);\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"invalid\", [\n                { name: \"field1\", type: ScalarType.INT_32 },\n            ]);\n\n            expect(() => {\n                decodeSharedDictionary(completeencodedStrings, new IntWrapper(0), columnMetaencodedStrings, 1);\n            }).toThrow(\"Currently only optional string fields are implemented for a struct.\");\n        });\n    });\n\n    describe(\"offset tracking\", () => {\n        it(\"should correctly advance offset through all streams\", () => {\n            const dictionaryStrings = [\"a\", \"b\", \"c\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n\n            const field1Streams = encodeStructField([0, 1], [true, true]);\n            const field2Streams = encodeStructField([1, 2], [true, true]);\n\n            const completeencodedStrings = concatenateBuffers(lengthStream, dataStream, field1Streams, field2Streams);\n            const columnMetaencodedStrings = createColumnMetadataForStruct(\"track\", [\n                { name: \"field1\" },\n                { name: \"field2\" },\n            ]);\n\n            const offset = new IntWrapper(0);\n            const initialOffset = offset.get();\n            const result = decodeSharedDictionary(completeencodedStrings, offset, columnMetaencodedStrings, 2);\n\n            expect(result).toHaveLength(2);\n            expect(offset.get()).toBeGreaterThan(initialOffset);\n            expect(offset.get()).toBe(completeencodedStrings.length);\n        });\n    });\n});\n"]}