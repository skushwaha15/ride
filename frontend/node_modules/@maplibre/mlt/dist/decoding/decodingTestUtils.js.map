{"version":3,"file":"decodingTestUtils.js","sourceRoot":"","sources":["../../src/decoding/decodingTestUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { PhysicalStreamType } from \"../metadata/tile/physicalStreamType\";\nimport { LogicalStreamType } from \"../metadata/tile/logicalStreamType\";\nimport { LogicalLevelTechnique } from \"../metadata/tile/logicalLevelTechnique\";\nimport { PhysicalLevelTechnique } from \"../metadata/tile/physicalLevelTechnique\";\nimport { DictionaryType } from \"../metadata/tile/dictionaryType\";\nimport { LengthType } from \"../metadata/tile/lengthType\";\nimport { OffsetType } from \"../metadata/tile/offsetType\";\nimport { type RleEncodedStreamMetadata, type StreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport IntWrapper from \"./intWrapper\";\nimport { type Column, type Field, ComplexType, ScalarType } from \"../metadata/tileset/tilesetMetadata\";\nimport { encodeBooleanRle, encodeStrings, createStringLengths } from \"../encoding/encodingUtils\";\nimport { encodeVarintInt32Value, encodeVarintInt32 } from \"../encoding/integerEncodingUtils\";\n\n/**\n * Creates basic stream metadata with logical techniques.\n */\nexport function createStreamMetadata(\n    logicalTechnique1: LogicalLevelTechnique,\n    logicalTechnique2: LogicalLevelTechnique = LogicalLevelTechnique.NONE,\n    numValues: number = 3,\n): StreamMetadata {\n    return {\n        physicalStreamType: PhysicalStreamType.DATA,\n        logicalStreamType: new LogicalStreamType(DictionaryType.NONE),\n        logicalLevelTechnique1: logicalTechnique1,\n        logicalLevelTechnique2: logicalTechnique2,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues,\n        byteLength: 10,\n        decompressedCount: numValues,\n    };\n}\n\n/**\n * Creates RLE-encoded stream metadata.\n */\nexport function createRleMetadata(\n    logicalTechnique1: LogicalLevelTechnique,\n    logicalTechnique2: LogicalLevelTechnique,\n    runs: number,\n    numRleValues: number,\n): RleEncodedStreamMetadata {\n    return {\n        physicalStreamType: PhysicalStreamType.DATA,\n        logicalStreamType: new LogicalStreamType(DictionaryType.NONE),\n        logicalLevelTechnique1: logicalTechnique1,\n        logicalLevelTechnique2: logicalTechnique2,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues: runs * 2,\n        byteLength: 10,\n        decompressedCount: numRleValues,\n        runs,\n        numRleValues,\n    };\n}\n\n/**\n * Creates column metadata for STRUCT type columns.\n */\nexport function createColumnMetadataForStruct(\n    columnName: string,\n    childFields: Array<{ name: string; type?: number }>,\n): Column {\n    const children: Field[] = childFields.map((fieldConfig) => ({\n        name: fieldConfig.name,\n        nullable: true,\n        scalarField: {\n            physicalType: fieldConfig.type ?? ScalarType.STRING,\n            type: \"physicalType\" as const,\n        },\n        type: \"scalarField\" as const,\n    }));\n\n    return {\n        name: columnName,\n        nullable: false,\n        complexType: {\n            physicalType: ComplexType.STRUCT,\n            children,\n            type: \"physicalType\" as const,\n        },\n        type: \"complexType\" as const,\n    };\n}\n\n/**\n * Creates a single stream with metadata and data.\n */\nexport function createStream(\n    physicalType: PhysicalStreamType,\n    data: Uint8Array,\n    options: {\n        logical?: LogicalStreamType;\n        technique?: PhysicalLevelTechnique;\n        count?: number;\n    } = {},\n): Uint8Array {\n    const count = options.count ?? 0;\n    return buildEncodedStream(\n        {\n            physicalStreamType: physicalType,\n            logicalStreamType: options.logical ?? new LogicalStreamType(),\n            logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n            logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n            physicalLevelTechnique: options.technique ?? PhysicalLevelTechnique.NONE,\n            numValues: count,\n            byteLength: data.length,\n            decompressedCount: count,\n        },\n        data,\n    );\n}\n\n/**\n * Encodes FSST-compressed strings into a complete stream.\n * This uses hardcoded test data: [\"cat\", \"dog\", \"cat\"]\n * @returns Encoded Uint8Array that can be passed to decodeString\n */\nexport function encodeFsstStrings(): Uint8Array {\n    const symbolTable = new Uint8Array([99, 97, 116, 100, 111, 103]); // \"catdog\"\n    const symbolLengths = new Int32Array([3, 3]);\n    const compressedDictionary = new Uint8Array([0, 1]);\n    const dictionaryLengths = new Int32Array([3, 3]);\n    const offsets = new Int32Array([0, 1, 0]); // \"cat\", \"dog\", \"cat\"\n    const numValues = 3;\n\n    return concatenateBuffers(\n        createStream(PhysicalStreamType.PRESENT, encodeBooleanRle(new Array(numValues).fill(true)), {\n            technique: PhysicalLevelTechnique.VARINT,\n            count: numValues,\n        }),\n        createStream(PhysicalStreamType.DATA, symbolTable, {\n            logical: new LogicalStreamType(DictionaryType.FSST),\n        }),\n        createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(symbolLengths), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.SYMBOL),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: symbolLengths.length,\n        }),\n        createStream(PhysicalStreamType.OFFSET, encodeVarintInt32(offsets), {\n            logical: new LogicalStreamType(undefined, OffsetType.STRING),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: offsets.length,\n        }),\n        createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(dictionaryLengths), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.DICTIONARY),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: dictionaryLengths.length,\n        }),\n        createStream(PhysicalStreamType.DATA, compressedDictionary, {\n            logical: new LogicalStreamType(DictionaryType.SINGLE),\n        }),\n    );\n}\n\n/**\n * Encodes a shared dictionary for struct fields.\n * @param dictionaryStrings - Array of unique strings in the dictionary\n * @param options - Encoding options\n * @returns Object containing length and data streams\n */\nexport function encodeSharedDictionary(\n    dictionaryStrings: string[],\n    options: { useFsst?: boolean; dictionaryType?: DictionaryType } = {},\n): {\n    lengthStream: Uint8Array;\n    dataStream: Uint8Array;\n    symbolLengthStream?: Uint8Array;\n    symbolDataStream?: Uint8Array;\n} {\n    const { useFsst = false, dictionaryType = DictionaryType.SHARED } = options;\n\n    const encodedDictionary = encodeStrings(dictionaryStrings);\n    const dictionaryLengths = createStringLengths(dictionaryStrings);\n\n    const lengthStream = createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(new Int32Array(dictionaryLengths)), {\n        logical: new LogicalStreamType(undefined, undefined, LengthType.DICTIONARY),\n        technique: PhysicalLevelTechnique.VARINT,\n        count: dictionaryLengths.length,\n    });\n\n    const dataStream = createStream(PhysicalStreamType.DATA, encodedDictionary, {\n        logical: new LogicalStreamType(dictionaryType),\n        count: encodedDictionary.length,\n    });\n\n    if (useFsst) {\n        const symbolTable = new Uint8Array([99, 97, 116, 100, 111, 103]); // \"catdog\"\n        const symbolLengths = new Int32Array([3, 3]);\n\n        const symbolLengthStream = createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(symbolLengths), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.SYMBOL),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: symbolLengths.length,\n        });\n\n        const symbolDataStream = createStream(PhysicalStreamType.DATA, symbolTable, {\n            logical: new LogicalStreamType(DictionaryType.FSST),\n            count: symbolTable.length,\n        });\n\n        return { lengthStream, dataStream, symbolLengthStream, symbolDataStream };\n    }\n\n    return { lengthStream, dataStream };\n}\n\n/**\n * Encodes streams for a struct field.\n * @param offsetIndices - Indices into the shared dictionary\n * @param presentValues - Boolean array indicating which values are present\n * @param isPresent - Whether the field itself is present\n * @returns Encoded streams for the field\n */\nexport function encodeStructField(\n    offsetIndices: number[],\n    presentValues: boolean[],\n    isPresent: boolean = true,\n): Uint8Array {\n    if (!isPresent) {\n        return encodeNumStreams(0);\n    }\n\n    const numStreamsEncoded = encodeNumStreams(2);\n    const encodedPresent = createPresentStream(presentValues);\n    const encodedOffsets = createOffsetStream(offsetIndices);\n\n    return concatenateBuffers(numStreamsEncoded, encodedPresent, encodedOffsets);\n}\n\nfunction encodeNumStreams(numStreams: number): Uint8Array {\n    const buffer = new Uint8Array(5);\n    const offset = new IntWrapper(0);\n    encodeVarintInt32Value(numStreams, buffer, offset);\n    return buffer.slice(0, offset.get());\n}\n\nfunction createPresentStream(presentValues: boolean[]): Uint8Array {\n    const metadata = {\n        physicalStreamType: PhysicalStreamType.PRESENT,\n        logicalStreamType: new LogicalStreamType(DictionaryType.NONE),\n        logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n        logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues: presentValues.length,\n        byteLength: 0,\n        decompressedCount: presentValues.length,\n    };\n    return buildEncodedStream(metadata, encodeBooleanRle(presentValues));\n}\n\nfunction createOffsetStream(offsetIndices: number[]): Uint8Array {\n    const metadata = {\n        physicalStreamType: PhysicalStreamType.OFFSET,\n        logicalStreamType: new LogicalStreamType(undefined, OffsetType.STRING),\n        logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n        logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues: offsetIndices.length,\n        byteLength: 0,\n        decompressedCount: offsetIndices.length,\n    };\n    return buildEncodedStream(metadata, encodeVarintInt32(new Int32Array(offsetIndices)));\n}\n\n/**\n * Builds a complete encoded stream by combining metadata and data.\n */\nexport function buildEncodedStream(\n    streamMetadata: StreamMetadata | RleEncodedStreamMetadata,\n    encodedData: Uint8Array,\n): Uint8Array {\n    const updatedMetadata = {\n        ...streamMetadata,\n        byteLength: encodedData.length,\n    };\n\n    const metadataBuffer = encodeStreamMetadata(updatedMetadata);\n    const result = new Uint8Array(metadataBuffer.length + encodedData.length);\n    result.set(metadataBuffer, 0);\n    result.set(encodedData, metadataBuffer.length);\n\n    return result;\n}\n\n/**\n * Encodes stream metadata into binary format.\n * - Byte 1: Stream type (physical type in upper 4 bits, logical subtype in lower 4 bits)\n * - Byte 2: Encodings (llt1[5-7], llt2[2-4], plt[0-1])\n * - Varints: numValues, byteLength\n * - If RLE: Varints: runs, numRleValues\n */\nexport function encodeStreamMetadata(metadata: StreamMetadata | RleEncodedStreamMetadata): Uint8Array {\n    const buffer = new Uint8Array(100);\n    let writeOffset = 0;\n\n    // Byte 1: Stream type\n    buffer[writeOffset++] = encodeStreamTypeByte(metadata);\n\n    // Byte 2: Encoding techniques\n    buffer[writeOffset++] = encodeEncodingsByte(metadata);\n\n    // Variable-length fields\n    const offset = new IntWrapper(writeOffset);\n    encodeVarintInt32Value(metadata.numValues, buffer, offset);\n    encodeVarintInt32Value(metadata.byteLength, buffer, offset);\n\n    // RLE-specific fields\n    if (isRleMetadata(metadata)) {\n        encodeVarintInt32Value(metadata.runs, buffer, offset);\n        encodeVarintInt32Value(metadata.numRleValues, buffer, offset);\n    }\n\n    return buffer.slice(0, offset.get());\n}\n\nfunction encodeStreamTypeByte(metadata: StreamMetadata | RleEncodedStreamMetadata): number {\n    const physicalTypeIndex = Object.values(PhysicalStreamType).indexOf(metadata.physicalStreamType);\n    const lowerNibble = getLogicalSubtypeValue(metadata);\n    return (physicalTypeIndex << 4) | lowerNibble;\n}\n\nfunction getLogicalSubtypeValue(metadata: StreamMetadata | RleEncodedStreamMetadata): number {\n    const { physicalStreamType, logicalStreamType } = metadata;\n\n    switch (physicalStreamType) {\n        case PhysicalStreamType.DATA:\n            return logicalStreamType.dictionaryType !== undefined\n                ? Object.values(DictionaryType).indexOf(logicalStreamType.dictionaryType)\n                : 0;\n        case PhysicalStreamType.OFFSET:\n            return logicalStreamType.offsetType !== undefined\n                ? Object.values(OffsetType).indexOf(logicalStreamType.offsetType)\n                : 0;\n        case PhysicalStreamType.LENGTH:\n            return logicalStreamType.lengthType !== undefined\n                ? Object.values(LengthType).indexOf(logicalStreamType.lengthType)\n                : 0;\n        default:\n            return 0;\n    }\n}\n\nfunction encodeEncodingsByte(metadata: StreamMetadata | RleEncodedStreamMetadata): number {\n    const llt1Index = Object.values(LogicalLevelTechnique).indexOf(metadata.logicalLevelTechnique1);\n    const llt2Index = Object.values(LogicalLevelTechnique).indexOf(metadata.logicalLevelTechnique2);\n    const pltIndex = Object.values(PhysicalLevelTechnique).indexOf(metadata.physicalLevelTechnique);\n    return (llt1Index << 5) | (llt2Index << 2) | pltIndex;\n}\n\nfunction isRleMetadata(metadata: StreamMetadata | RleEncodedStreamMetadata): metadata is RleEncodedStreamMetadata {\n    return \"runs\" in metadata && \"numRleValues\" in metadata;\n}\n\n/**\n * Concatenates multiple Uint8Array buffers into a single buffer.\n */\nexport function concatenateBuffers(...buffers: Uint8Array[]): Uint8Array {\n    const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n\n    for (const buffer of buffers) {\n        result.set(buffer, offset);\n        offset += buffer.length;\n    }\n\n    return result;\n}\n"]}