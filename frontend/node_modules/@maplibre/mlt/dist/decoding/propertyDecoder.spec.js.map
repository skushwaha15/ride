{"version":3,"file":"propertyDecoder.spec.js","sourceRoot":"","sources":["../../src/decoding/propertyDecoder.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect } from \"vitest\";\nimport { decodePropertyColumn } from \"./propertyDecoder\";\nimport IntWrapper from \"./intWrapper\";\nimport { ScalarType, type Column } from \"../metadata/tileset/tilesetMetadata\";\nimport { IntFlatVector } from \"../vector/flat/intFlatVector\";\nimport { LongFlatVector } from \"../vector/flat/longFlatVector\";\nimport { FloatFlatVector } from \"../vector/flat/floatFlatVector\";\nimport { DoubleFlatVector } from \"../vector/flat/doubleFlatVector\";\nimport { BooleanFlatVector } from \"../vector/flat/booleanFlatVector\";\nimport { IntSequenceVector } from \"../vector/sequence/intSequenceVector\";\nimport { LongSequenceVector } from \"../vector/sequence/longSequenceVector\";\nimport { IntConstVector } from \"../vector/constant/intConstVector\";\nimport { LongConstVector } from \"../vector/constant/longConstVector\";\nimport { StringDictionaryVector } from \"../vector/dictionary/stringDictionaryVector\";\nimport { createColumnMetadataForStruct, encodeSharedDictionary, encodeStructField } from \"./decodingTestUtils\";\nimport { concatenateBuffers } from \"../encoding/encodingUtils\";\nimport {\n    encodeInt32NoneColumn,\n    encodeInt32DeltaColumn,\n    encodeInt32RleColumn,\n    encodeInt32DeltaRleColumn,\n    encodeUint32Column,\n    encodeInt64NoneColumn,\n    encodeInt64DeltaColumn,\n    encodeInt64RleColumn,\n    encodeInt64DeltaRleColumn,\n    encodeInt64NullableColumn,\n    encodeUint64Column,\n    encodeUint64NullableColumn,\n    encodeFloatColumn,\n    encodeFloatNullableColumn,\n    encodeDoubleColumn,\n    encodeDoubleNullableColumn,\n    encodeBooleanColumn,\n    encodeBooleanNullableColumn,\n    encodeInt32NullableColumn,\n} from \"../encoding/propertyEncoder\";\n\nfunction createColumnMetadata(name: string, scalarType: number, nullable: boolean = false): Column {\n    return {\n        name: name,\n        nullable: nullable,\n        type: \"scalarType\",\n        scalarType: {\n            physicalType: scalarType,\n            type: \"physicalType\",\n        },\n    };\n}\n\ndescribe(\"decodePropertyColumn - INT_32\", () => {\n    it(\"should decode INT_32 column with NONE encoding (signed)\", () => {\n        const expectedValues = new Int32Array([2, -4, 6]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32NoneColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_32 column with DELTA encoding\", () => {\n        const expectedValues = new Int32Array([2, 4, 6]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32DeltaColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_32 column with RLE encoding\", () => {\n        const expectedValues = new Int32Array([100, 100, 100, -50, -50]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32RleColumn([\n            [3, 100],\n            [2, -50],\n        ]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_32 column with DELTA+RLE encoding\", () => {\n        const expectedValues = new Int32Array([10, 12, 14, 15, 16]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32DeltaRleColumn([\n            [1, 10],\n            [2, 2],\n            [2, 1],\n        ]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode nullable INT_32 column with null values\", () => {\n        const expectedValues = [2, null, -4, null, 6];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, true);\n        const encodedData = encodeInt32NullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_32 SEQUENCE vector\", () => {\n        const numValues = 5;\n        const value = 10;\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32DeltaRleColumn([[numValues, value]]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, numValues);\n\n        expect(result).toBeInstanceOf(IntSequenceVector);\n        const seqVec = result as IntSequenceVector;\n        expect(seqVec.getValue(0)).toBe(value);\n        expect(seqVec.getValue(1)).toBe(value + value);\n        expect(seqVec.getValue(2)).toBe(value + value * 2);\n    });\n\n    it(\"should decode INT_32 CONST vector\", () => {\n        const numValues = 5;\n        const constValue = 42;\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32RleColumn([[numValues, constValue]]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, numValues);\n\n        expect(result).toBeInstanceOf(IntConstVector);\n        const constVec = result as IntConstVector;\n        expect(constVec.getValue(0)).toBe(constValue);\n        expect(constVec.getValue(4)).toBe(constValue);\n    });\n});\n\ndescribe(\"decodePropertyColumn - UINT_32\", () => {\n    it(\"should decode UINT_32 column with NONE encoding (unsigned)\", () => {\n        const expectedValues = new Uint32Array([2, 4, 6, 100]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.UINT_32, false);\n        const encodedData = encodeUint32Column(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n});\n\ndescribe(\"decodePropertyColumn - INT_64\", () => {\n    it(\"should decode INT_64 column with NONE encoding (signed)\", () => {\n        const expectedValues = new BigInt64Array([2n, -4n, 6n]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64NoneColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_64 column with DELTA encoding\", () => {\n        const expectedValues = new BigInt64Array([2n, 4n, 6n]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64DeltaColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_64 column with RLE encoding\", () => {\n        const expectedValues = new BigInt64Array([100n, 100n, 100n, -50n, -50n]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64RleColumn([\n            [3, 100n],\n            [2, -50n],\n        ]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_64 column with DELTA+RLE encoding\", () => {\n        const expectedValues = new BigInt64Array([10n, 12n, 14n, 15n, 16n]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64DeltaRleColumn([\n            [1, 10n],\n            [2, 2n],\n            [2, 1n],\n        ]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode nullable INT_64 column with null values\", () => {\n        const expectedValues = [2n, null, -4n, null, 6n];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, true);\n        const encodedData = encodeInt64NullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode INT_64 SEQUENCE vector\", () => {\n        const numValues = 5;\n        const value = 10n;\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64DeltaRleColumn([[numValues, value]]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, numValues);\n\n        expect(result).toBeInstanceOf(LongSequenceVector);\n        const seqVec = result as LongSequenceVector;\n        expect(seqVec.getValue(0)).toBe(value);\n        expect(seqVec.getValue(1)).toBe(value + value);\n        expect(seqVec.getValue(2)).toBe(value + value * 2n);\n    });\n\n    it(\"should decode INT_64 CONST vector\", () => {\n        const numValues = 5;\n        const constValue = 42n;\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.INT_64, false);\n        const encodedData = encodeInt64RleColumn([[numValues, constValue]]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, numValues);\n\n        expect(result).toBeInstanceOf(LongConstVector);\n        const constVec = result as LongConstVector;\n        expect(constVec.getValue(0)).toBe(constValue);\n        expect(constVec.getValue(4)).toBe(constValue);\n    });\n});\n\ndescribe(\"decodePropertyColumn - UINT_64\", () => {\n    it(\"should decode UINT_64 column with NONE encoding (unsigned)\", () => {\n        const expectedValues = new BigUint64Array([2n, 4n, 6n, 100n]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.UINT_64, false);\n        const encodedData = encodeUint64Column(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should decode nullable UINT_64 column with null values\", () => {\n        const expectedValues = [2n, null, 4n, null, 6n];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.UINT_64, true);\n        const encodedData = encodeUint64NullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(LongFlatVector);\n        const resultVec = result as LongFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n});\n\ndescribe(\"decodePropertyColumn - FLOAT\", () => {\n    it(\"should decode non-nullable FLOAT column\", () => {\n        const expectedValues = new Float32Array([1.5, 2.7, -3.14, 4.2]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.FLOAT, false);\n        const encodedData = encodeFloatColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(FloatFlatVector);\n        const resultVec = result as FloatFlatVector;\n        expect(resultVec.size).toBe(expectedValues.length);\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBeCloseTo(expectedValues[i], 5);\n        }\n    });\n\n    it(\"should decode nullable FLOAT column with null values\", () => {\n        const expectedValues = [1.5, null, 2.7, null, 3.14];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.FLOAT, true);\n        const encodedData = encodeFloatNullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(FloatFlatVector);\n        const resultVec = result as FloatFlatVector;\n        expect(resultVec.size).toBe(expectedValues.length);\n        expect(resultVec.getValue(0)).toBeCloseTo(1.5, 5);\n        expect(resultVec.getValue(1)).toBe(null); // null value\n        expect(resultVec.getValue(2)).toBeCloseTo(2.7, 5);\n        expect(resultVec.getValue(3)).toBe(null); // null value\n        expect(resultVec.getValue(4)).toBeCloseTo(3.14, 5);\n    });\n\n    it(\"should handle offset correctly after decoding FLOAT column\", () => {\n        const expectedValues = new Float32Array([1.0, 2.0, 3.0]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.FLOAT, false);\n        const encodedData = encodeFloatColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        // Verify offset was advanced correctly\n        expect(offset.get()).toBe(encodedData.length);\n    });\n});\n\ndescribe(\"decodePropertyColumn - BOOLEAN\", () => {\n    it(\"should decode non-nullable BOOLEAN column with RLE\", () => {\n        const booleanValues = [true, false, true, true, false, false, false, true];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.BOOLEAN, false);\n        const encodedData = encodeBooleanColumn(booleanValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, booleanValues.length);\n\n        expect(result).toBeInstanceOf(BooleanFlatVector);\n        const boolVec = result as BooleanFlatVector;\n        for (let i = 0; i < booleanValues.length; i++) {\n            expect(boolVec.getValue(i)).toBe(booleanValues[i]);\n        }\n    });\n\n    it(\"should decode nullable BOOLEAN column with RLE and present stream\", () => {\n        const expectedValues = [true, null, false, null, true];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.BOOLEAN, true);\n        const encodedData = encodeBooleanNullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(BooleanFlatVector);\n        const boolVec = result as BooleanFlatVector;\n        expect(boolVec.getValue(0)).toBe(true);\n        expect(boolVec.getValue(1)).toBe(null);\n        expect(boolVec.getValue(2)).toBe(false);\n        expect(boolVec.getValue(3)).toBe(null);\n        expect(boolVec.getValue(4)).toBe(true);\n    });\n});\n\ndescribe(\"decodePropertyColumn - DOUBLE\", () => {\n    it(\"should decode non-nullable DOUBLE column\", () => {\n        const expectedValues = new Float32Array([1.2345, 5.4321, 1.33742]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.DOUBLE, false);\n        const encodedData = encodeDoubleColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        expect(result).toBeInstanceOf(DoubleFlatVector);\n        const resultVec = result as DoubleFlatVector;\n        expect(resultVec.size).toBe(expectedValues.length);\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBeCloseTo(expectedValues[i], 5);\n        }\n    });\n\n    it(\"should decode nullable DOUBLE column with null values\", () => {\n        const expectedValues = [1.5, null, 2.7, null, 3.14159];\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.DOUBLE, true);\n        const encodedData = encodeDoubleNullableColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(encodedData, offset, columnMetadata, 2, expectedValues.length);\n\n        expect(result).toBeInstanceOf(DoubleFlatVector);\n        const resultVec = result as DoubleFlatVector;\n        expect(resultVec.size).toBe(expectedValues.length);\n        expect(resultVec.getValue(0)).toBeCloseTo(1.5, 5);\n        expect(resultVec.getValue(1)).toBe(null); // null value\n        expect(resultVec.getValue(2)).toBeCloseTo(2.7, 5);\n        expect(resultVec.getValue(3)).toBe(null); // null value\n        expect(resultVec.getValue(4)).toBeCloseTo(3.14159, 5);\n    });\n\n    it(\"should handle offset correctly after decoding DOUBLE column\", () => {\n        const expectedValues = new Float32Array([1.33742, 1.2345, 5.4321]);\n        const columnMetadata = createColumnMetadata(\"testColumn\", ScalarType.DOUBLE, false);\n        const encodedData = encodeDoubleColumn(expectedValues);\n        const offset = new IntWrapper(0);\n\n        decodePropertyColumn(encodedData, offset, columnMetadata, 1, expectedValues.length);\n\n        // Verify offset was advanced correctly\n        expect(offset.get()).toBe(encodedData.length);\n    });\n});\n\ndescribe(\"decodePropertyColumn - STRING\", () => {\n    describe(\"basic functionality\", () => {\n        it(\"should decode single field with shared dictionary\", () => {\n            const dictionaryStrings = [\"apple\", \"banana\", \"peach\", \"date\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n            const fieldStreams = encodeStructField([0, 1, 2, 3], [true, true, true, true]);\n            const completeData = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n            const columnMetadata = createColumnMetadataForStruct(\"address:\", [{ name: \"street\" }]);\n            const offset = new IntWrapper(0);\n            const result = decodePropertyColumn(completeData, offset, columnMetadata, 1, dictionaryStrings.length);\n\n            expect(result).toHaveLength(1);\n            expect(result[0]).toBeInstanceOf(StringDictionaryVector);\n            expect(result[0].name).toBe(\"address:street\");\n            for (let i = 0; i < dictionaryStrings.length; i++) {\n                expect(result[0].getValue(i)).toBe(dictionaryStrings[i]);\n            }\n        });\n\n        it(\"should decode shared dictionary when numStreams matches encoder output (3 + N*2)\", () => {\n            const dictionaryStrings = [\"apple\", \"banana\", \"peach\", \"date\"];\n            const { lengthStream, dataStream } = encodeSharedDictionary(dictionaryStrings);\n            const fieldStreams = encodeStructField([0, 1, 2, 3], [true, true, true, true]);\n            const completeData = concatenateBuffers(lengthStream, dataStream, fieldStreams);\n            const columnMetadata = createColumnMetadataForStruct(\"address:\", [{ name: \"street\" }]);\n            const offset = new IntWrapper(0);\n            const result = decodePropertyColumn(completeData, offset, columnMetadata, 5, dictionaryStrings.length);\n\n            expect(result).toHaveLength(1);\n            expect(result[0]).toBeInstanceOf(StringDictionaryVector);\n            expect(result[0].name).toBe(\"address:street\");\n            for (let i = 0; i < dictionaryStrings.length; i++) {\n                expect(result[0].getValue(i)).toBe(dictionaryStrings[i]);\n            }\n        });\n    });\n});\n\ndescribe(\"decodePropertyColumn - Edge Cases\", () => {\n    it(\"should filter columns with propertyColumnNames set\", () => {\n        const expectedValues = new Int32Array([1, 2, 3]);\n        const columnMetadata = createColumnMetadata(\"includedColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32NoneColumn(expectedValues);\n        const propertyColumnNames = new Set([\"includedColumn\"]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(\n            encodedData,\n            offset,\n            columnMetadata,\n            1,\n            expectedValues.length,\n            propertyColumnNames,\n        );\n\n        expect(result).toBeInstanceOf(IntFlatVector);\n        const resultVec = result as IntFlatVector;\n        for (let i = 0; i < expectedValues.length; i++) {\n            expect(resultVec.getValue(i)).toBe(expectedValues[i]);\n        }\n    });\n\n    it(\"should skip column when not in propertyColumnNames filter\", () => {\n        const expectedValues = new Int32Array([1, 2, 3]);\n        const columnMetadata = createColumnMetadata(\"excludedColumn\", ScalarType.INT_32, false);\n        const encodedData = encodeInt32NoneColumn(expectedValues);\n        const propertyColumnNames = new Set([\"someOtherColumn\"]);\n        const offset = new IntWrapper(0);\n\n        const result = decodePropertyColumn(\n            encodedData,\n            offset,\n            columnMetadata,\n            1,\n            expectedValues.length,\n            propertyColumnNames,\n        );\n\n        // Should return null and advance the offset past the skipped data\n        expect(result).toBe(null);\n        expect(offset.get()).toBe(encodedData.length);\n    });\n\n    it(\"should return null for empty columns (numStreams === 0)\", () => {\n        const columnMetadata = createColumnMetadata(\"emptyColumn\", ScalarType.INT_32, false);\n        const offset = new IntWrapper(0);\n        const data = new Uint8Array(0);\n\n        const result = decodePropertyColumn(data, offset, columnMetadata, 0, 0);\n\n        expect(result).toBeNull();\n    });\n\n    it(\"should return null for complex type with numStreams === 0\", () => {\n        const columnMetadata = createColumnMetadataForStruct(\"structColumn\", [\n            { name: \"field1\" },\n            { name: \"field2\" },\n        ]);\n        const offset = new IntWrapper(0);\n        const data = new Uint8Array(0);\n\n        const result = decodePropertyColumn(data, offset, columnMetadata, 0, 5);\n\n        expect(result).toBeNull();\n    });\n\n    it(\"should throw error for unsupported data type\", () => {\n        const columnMetadata = createColumnMetadata(\"unsupportedColumn\", ScalarType.INT_8, false);\n        const encodedData = encodeInt32NoneColumn(new Int32Array([1, 2, 3]));\n        const offset = new IntWrapper(0);\n\n        expect(() => {\n            decodePropertyColumn(encodedData, offset, columnMetadata, 1, 3);\n        }).toThrow();\n    });\n});\n"]}