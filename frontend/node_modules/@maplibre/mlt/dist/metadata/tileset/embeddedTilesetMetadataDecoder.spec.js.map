{"version":3,"file":"embeddedTilesetMetadataDecoder.spec.js","sourceRoot":"","sources":["../../../src/metadata/tileset/embeddedTilesetMetadataDecoder.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, it } from \"vitest\";\nimport { decodeField, decodeEmbeddedTileSetMetadata } from \"./embeddedTilesetMetadataDecoder\";\nimport IntWrapper from \"../../decoding/intWrapper\";\nimport { concatenateBuffers } from \"../../decoding/decodingTestUtils\";\nimport { ComplexType, ScalarType } from \"./tilesetMetadata\";\nimport {\n    encodeChildCount,\n    encodeFieldName,\n    encodeTypeCode,\n    scalarTypeCode,\n} from \"../../encoding/embeddedTilesetMetadataEncoder\";\n\nconst STRUCT_TYPE_CODE = 30;\n\ndescribe(\"embeddedTilesetMetadataDecoder\", () => {\n    describe(\"decodeField\", () => {\n        describe(\"scalar fields\", () => {\n            it(\"should decode non-nullable STRING field\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.STRING, false)),\n                    encodeFieldName(\"street\"),\n                );\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"street\");\n                expect(field.nullable).toBe(false);\n                expect(field.type).toBe(\"scalarField\");\n                expect(field.scalarField?.physicalType).toBe(ScalarType.STRING);\n            });\n\n            it(\"should decode nullable UINT_64 field\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.UINT_64, true)),\n                    encodeFieldName(\"population\"),\n                );\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"population\");\n                expect(field.nullable).toBe(true);\n                expect(field.type).toBe(\"scalarField\");\n                expect(field.scalarField?.physicalType).toBe(ScalarType.UINT_64);\n            });\n\n            it(\"should decode BOOLEAN field\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.BOOLEAN, false)),\n                    encodeFieldName(\"isActive\"),\n                );\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"isActive\");\n                expect(field.nullable).toBe(false);\n                expect(field.type).toBe(\"scalarField\");\n                expect(field.scalarField?.physicalType).toBe(ScalarType.BOOLEAN);\n            });\n\n            it(\"should decode non-nullable UINT_32 field\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.UINT_32, false)),\n                    encodeFieldName(\"count\"),\n                );\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"count\");\n                expect(field.nullable).toBe(false);\n                expect(field.type).toBe(\"scalarField\");\n                expect(field.scalarField?.physicalType).toBe(ScalarType.UINT_32);\n            });\n\n            it(\"should decode nullable FLOAT field\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.FLOAT, true)),\n                    encodeFieldName(\"temperature\"),\n                );\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"temperature\");\n                expect(field.nullable).toBe(true);\n                expect(field.type).toBe(\"scalarField\");\n                expect(field.scalarField?.physicalType).toBe(ScalarType.FLOAT);\n            });\n        });\n\n        describe(\"complex fields\", () => {\n            it(\"should decode STRUCT field with nested children\", () => {\n                const children = [\n                    {\n                        typeCode: scalarTypeCode(ScalarType.STRING, false),\n                        name: \"street\",\n                        nullable: false,\n                        physicalType: ScalarType.STRING,\n                    },\n                    {\n                        typeCode: scalarTypeCode(ScalarType.UINT_32, true),\n                        name: \"zipcode\",\n                        nullable: true,\n                        physicalType: ScalarType.UINT_32,\n                    },\n                ];\n\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(STRUCT_TYPE_CODE),\n                    encodeFieldName(\"address\"),\n                    encodeChildCount(children.length),\n                    ...children.flatMap((c) => [encodeTypeCode(c.typeCode), encodeFieldName(c.name)]),\n                );\n\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"address\");\n                expect(field.nullable).toBe(false);\n                expect(field.type).toBe(\"complexField\");\n                expect(field.complexField?.physicalType).toBe(ComplexType.STRUCT);\n                expect(field.complexField?.children).toHaveLength(children.length);\n\n                for (let i = 0; i < children.length; i++) {\n                    const child = children[i];\n\n                    expect(field.complexField?.children[i].name).toBe(child.name);\n                    expect(field.complexField?.children[i].nullable).toBe(child.nullable);\n                    expect(field.complexField?.children[i].scalarField?.physicalType).toBe(child.physicalType);\n                }\n            });\n        });\n\n        describe(\"deeply nested structures\", () => {\n            it(\"should decode 3-level nested STRUCT\", () => {\n                const leafChildren = [\n                    { typeCode: scalarTypeCode(ScalarType.FLOAT, false), name: \"lat\" },\n                    { typeCode: scalarTypeCode(ScalarType.FLOAT, false), name: \"lon\" },\n                ];\n\n                const buffer = concatenateBuffers(\n                    // Parent STRUCT \"location\"\n                    encodeTypeCode(STRUCT_TYPE_CODE),\n                    encodeFieldName(\"location\"),\n                    encodeChildCount(1),\n                    // Child STRUCT \"address\"\n                    encodeTypeCode(STRUCT_TYPE_CODE),\n                    encodeFieldName(\"address\"),\n                    encodeChildCount(1),\n                    // Grandchild STRUCT \"coordinates\"\n                    encodeTypeCode(STRUCT_TYPE_CODE),\n                    encodeFieldName(\"coordinates\"),\n                    encodeChildCount(leafChildren.length),\n                    // Great-grandchildren\n                    ...leafChildren.flatMap((c) => [encodeTypeCode(c.typeCode), encodeFieldName(c.name)]),\n                );\n\n                const field = decodeField(buffer, new IntWrapper(0));\n\n                expect(field.name).toBe(\"location\");\n                expect(field.type).toBe(\"complexField\");\n                expect(field.complexField?.physicalType).toBe(ComplexType.STRUCT);\n\n                const address = field.complexField?.children[0];\n                expect(address?.name).toBe(\"address\");\n                expect(address?.type).toBe(\"complexField\");\n\n                const coordinates = address?.complexField?.children[0];\n                expect(coordinates?.name).toBe(\"coordinates\");\n                expect(coordinates?.complexField?.children).toHaveLength(leafChildren.length);\n\n                for (let i = 0; i < leafChildren.length; i++) {\n                    const child = leafChildren[i];\n\n                    expect(coordinates?.complexField?.children[i].name).toBe(child.name);\n                    expect(coordinates?.complexField?.children[i].scalarField?.physicalType).toBe(ScalarType.FLOAT);\n                }\n            });\n        });\n\n        describe(\"offset tracking\", () => {\n            it(\"should correctly advance offset\", () => {\n                const buffer = concatenateBuffers(\n                    encodeTypeCode(scalarTypeCode(ScalarType.STRING, false)),\n                    encodeFieldName(\"test\"),\n                );\n                const offset = new IntWrapper(0);\n\n                decodeField(buffer, offset);\n\n                expect(offset.get()).toBe(buffer.length);\n            });\n        });\n\n        describe(\"error handling\", () => {\n            it(\"should throw error for unsupported typeCode\", () => {\n                const buffer = encodeTypeCode(999);\n\n                expect(() => {\n                    decodeField(buffer, new IntWrapper(0));\n                }).toThrow(\"Unsupported field type code 999. Supported: 10-29(scalars), 30(STRUCT)\");\n            });\n        });\n\n    });\n\n    describe(\"decodeEmbeddedTileSetMetadata\", () => {\n        it(\"should decode tileset with STRUCT column\", () => {\n            const buffer = concatenateBuffers(\n                encodeFieldName(\"\"),\n                encodeTypeCode(4096),\n                encodeChildCount(1),\n                encodeTypeCode(STRUCT_TYPE_CODE),\n                encodeFieldName(\"props\"),\n                encodeChildCount(1),\n                encodeTypeCode(scalarTypeCode(ScalarType.STRING, false)),\n                encodeFieldName(\"name\"),\n            );\n\n            const [metadata, extent] = decodeEmbeddedTileSetMetadata(buffer, new IntWrapper(0));\n\n            expect(extent).toBe(4096);\n            expect(metadata.featureTables[0].name).toBe(\"\");\n            expect(metadata.featureTables[0].columns[0].complexType.children).toHaveLength(1);\n        });\n    });\n});\n"]}