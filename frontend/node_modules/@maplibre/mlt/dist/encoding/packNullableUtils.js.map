{"version":3,"file":"packNullableUtils.js","sourceRoot":"","sources":["../../src/encoding/packNullableUtils.ts"],"names":[],"mappings":"AACA,OAAO,SAAS,MAAM,0BAA0B,CAAC;AAEjD,MAAM,UAAU,YAAY,CAA+B,IAAO,EAAE,WAA6B;IAC7F,0EAA0E;IAC1E,IAAI,CAAC,WAAW,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;IAEzB,8DAA8D;IAC9D,mEAAmE;IACnE,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YACrB,WAAW,EAAE,CAAC;QAClB,CAAC;IACL,CAAC;IAED,+DAA+D;IAC/D,MAAM,WAAW,GAAG,IAAI,CAAC,WAAoC,CAAC;IAC9D,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,WAAW,CAAM,CAAC;IAEjD,0DAA0D;IAC1D,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5B,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YACrB,MAAM,CAAC,OAAO,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAChC,CAAC;IACL,CAAC;IAED,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,mBAAmB,CAAC,IAAgB,EAAE,QAAgB,EAAE,WAA6B;IACjG,0EAA0E;IAC1E,IAAI,CAAC,WAAW,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,MAAM,cAAc,GAAG,IAAI,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAErD,8DAA8D;IAC9D,uDAAuD;IACvD,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE,CAAC;QAChC,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YACrB,WAAW,EAAE,CAAC;QAClB,CAAC;IACL,CAAC;IAED,sEAAsE;IACtE,MAAM,YAAY,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;IAChE,MAAM,eAAe,GAAG,IAAI,SAAS,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;IAEjE,4DAA4D;IAC5D,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE,CAAC;QAChC,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YACrB,MAAM,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACpC,eAAe,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;QAC9C,CAAC;IACL,CAAC;IAED,OAAO,eAAe,CAAC,SAAS,EAAE,CAAC;AACvC,CAAC","sourcesContent":["import { type TypedArrayConstructor, type TypedArrayInstance } from \"../decoding/unpackNullableUtils\";\nimport BitVector from \"../vector/flat/bitVector\";\n\nexport function packNullable<T extends TypedArrayInstance>(data: T, presentBits: BitVector | null): T {\n    // Non-nullable case: if no mask is provided, the data is already \"packed\"\n    if (!presentBits) {\n        return data;\n    }\n\n    const size = data.length;\n\n    // 1. First pass: Count how many elements are actually present\n    // This is required to allocate the correct size for the TypedArray\n    let packedCount = 0;\n    for (let i = 0; i < size; i++) {\n        if (presentBits.get(i)) {\n            packedCount++;\n        }\n    }\n\n    // 2. Create a new array of the same type with the reduced size\n    const constructor = data.constructor as TypedArrayConstructor;\n    const result = new constructor(packedCount) as T;\n\n    // 3. Second pass: Fill the result array with valid values\n    let counter = 0;\n    for (let i = 0; i < size; i++) {\n        if (presentBits.get(i)) {\n            result[counter++] = data[i];\n        }\n    }\n\n    return result;\n}\n\nexport function packNullableBoolean(data: Uint8Array, dataSize: number, presentBits: BitVector | null): Uint8Array {\n    // Non-nullable case: if no mask is provided, the data is already \"packed\"\n    if (!presentBits) {\n        return data;\n    }\n\n    const inputBitVector = new BitVector(data, dataSize);\n\n    // 1. Calculate how many bits are actually marked as 'present'\n    // This determines the size of the final packed buffer.\n    let packedCount = 0;\n    for (let i = 0; i < dataSize; i++) {\n        if (presentBits.get(i)) {\n            packedCount++;\n        }\n    }\n\n    // 2. Initialize the result BitVector with the correct compressed size\n    const resultBuffer = new Uint8Array(Math.ceil(packedCount / 8));\n    const resultBitVector = new BitVector(resultBuffer, packedCount);\n\n    // 3. Fill the result: only copy bits where the mask is true\n    let targetIndex = 0;\n    for (let i = 0; i < dataSize; i++) {\n        if (presentBits.get(i)) {\n            const value = inputBitVector.get(i);\n            resultBitVector.set(targetIndex++, value);\n        }\n    }\n\n    return resultBitVector.getBuffer();\n}\n"]}