{"version":3,"file":"stringEncoder.js","sourceRoot":"","sources":["../../src/encoding/stringEncoder.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,qCAAqC,CAAC;AACzE,OAAO,EAAE,iBAAiB,EAAE,MAAM,oCAAoC,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,MAAM,iCAAiC,CAAC;AACjE,OAAO,EAAE,UAAU,EAAE,MAAM,6BAA6B,CAAC;AACzD,OAAO,EAAE,UAAU,EAAE,MAAM,6BAA6B,CAAC;AACzD,OAAO,EAAE,sBAAsB,EAAE,MAAM,yCAAyC,CAAC;AACjF,OAAO,EAAE,qBAAqB,EAAE,MAAM,wCAAwC,CAAC;AAE/E,OAAO,UAAU,MAAM,wBAAwB,CAAC;AAChD,OAAO,EAAE,gBAAgB,EAAE,aAAa,EAAE,mBAAmB,EAAE,kBAAkB,EAAE,MAAM,iBAAiB,CAAC;AAC3G,OAAO,EAAE,sBAAsB,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAEnF;;;;GAIG;AACH,MAAM,UAAU,kBAAkB,CAAC,OAA0B;IACzD,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;IAChD,MAAM,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAe,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;IACtE,MAAM,WAAW,GAAG,aAAa,CAAC,cAAc,CAAC,CAAC;IAElD,MAAM,OAAO,GAAiB,EAAE,CAAC;IAEjC,oCAAoC;IACpC,IAAI,OAAO,EAAE,CAAC;QACV,MAAM,iBAAiB,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;QACzD,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,OAAO,EAAE,gBAAgB,CAAC,iBAAiB,CAAC,EAAE;YAC1E,SAAS,EAAE,sBAAsB,CAAC,MAAM;YACxC,KAAK,EAAE,iBAAiB,CAAC,MAAM;SAClC,CAAC,CACL,CAAC;IACN,CAAC;IAED,oBAAoB;IACpB,MAAM,OAAO,GAAG,mBAAmB,CAAC,cAAc,CAAC,CAAC;IACpD,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;QAChF,OAAO,EAAE,IAAI,iBAAiB,CAAC,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC,UAAU,CAAC;QAC3E,SAAS,EAAE,sBAAsB,CAAC,MAAM;QACxC,KAAK,EAAE,OAAO,CAAC,MAAM;KACxB,CAAC,CACL,CAAC;IAEF,kBAAkB;IAClB,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,IAAI,EAAE,WAAW,EAAE;QAC/C,OAAO,EAAE,IAAI,iBAAiB,CAAC,cAAc,CAAC,IAAI,CAAC;KACtD,CAAC,CACL,CAAC;IAEF,OAAO,kBAAkB,CAAC,GAAG,OAAO,CAAC,CAAC;AAC1C,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,uBAAuB,CAAC,OAA0B;IAC9D,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;IAChD,MAAM,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAe,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;IAEtE,sCAAsC;IACtC,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;IAC1D,MAAM,SAAS,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/D,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;QACrC,MAAM,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YACvB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,EAAE,CAAC,CAAC;QAC5D,CAAC;QACD,OAAO,MAAM,CAAC;IAClB,CAAC,CAAC,CAAC;IAEH,MAAM,WAAW,GAAG,aAAa,CAAC,aAAa,CAAC,CAAC;IACjD,MAAM,OAAO,GAAG,mBAAmB,CAAC,aAAa,CAAC,CAAC;IAEnD,MAAM,OAAO,GAAiB,EAAE,CAAC;IAEjC,oCAAoC;IACpC,IAAI,OAAO,EAAE,CAAC;QACV,MAAM,iBAAiB,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;QACzD,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,OAAO,EAAE,gBAAgB,CAAC,iBAAiB,CAAC,EAAE;YAC1E,SAAS,EAAE,sBAAsB,CAAC,MAAM;YACxC,KAAK,EAAE,iBAAiB,CAAC,MAAM;SAClC,CAAC,CACL,CAAC;IACN,CAAC;IAED,oBAAoB;IACpB,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;QAChF,OAAO,EAAE,IAAI,iBAAiB,CAAC,SAAS,EAAE,UAAU,CAAC,MAAM,CAAC;QAC5D,SAAS,EAAE,sBAAsB,CAAC,MAAM;QACxC,KAAK,EAAE,OAAO,CAAC,MAAM;KACxB,CAAC,CACL,CAAC;IAEF,qCAAqC;IACrC,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,MAAM,EAAE,iBAAiB,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;QAChF,OAAO,EAAE,IAAI,iBAAiB,CAAC,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC,UAAU,CAAC;QAC3E,SAAS,EAAE,sBAAsB,CAAC,MAAM;QACxC,KAAK,EAAE,OAAO,CAAC,MAAM;KACxB,CAAC,CACL,CAAC;IAEF,kBAAkB;IAClB,OAAO,CAAC,IAAI,CACR,YAAY,CAAC,kBAAkB,CAAC,IAAI,EAAE,WAAW,EAAE;QAC/C,OAAO,EAAE,IAAI,iBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC;KACxD,CAAC,CACL,CAAC;IAEF,OAAO,kBAAkB,CAAC,GAAG,OAAO,CAAC,CAAC;AAC1C,CAAC;AAED,SAAS,YAAY,CACjB,YAAgC,EAChC,IAAgB,EAChB,UAII,EAAE;IAEN,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC;IACjC,OAAO,kBAAkB,CACrB;QACI,kBAAkB,EAAE,YAAY;QAChC,iBAAiB,EAAE,OAAO,CAAC,OAAO,IAAI,IAAI,iBAAiB,EAAE;QAC7D,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,OAAO,CAAC,SAAS,IAAI,sBAAsB,CAAC,IAAI;QACxE,SAAS,EAAE,KAAK;QAChB,UAAU,EAAE,IAAI,CAAC,MAAM;QACvB,iBAAiB,EAAE,KAAK;KAC3B,EACD,IAAI,CACP,CAAC;AACN,CAAC;AAED,SAAS,kBAAkB,CAAC,cAA8B,EAAE,WAAuB;IAC/E,MAAM,eAAe,GAAG;QACpB,GAAG,cAAc;QACjB,UAAU,EAAE,WAAW,CAAC,MAAM;KACjC,CAAC;IAEF,MAAM,cAAc,GAAG,oBAAoB,CAAC,eAAe,CAAC,CAAC;IAC7D,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,cAAc,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;IAC1E,MAAM,CAAC,GAAG,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;IAC9B,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;IAE/C,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,SAAS,oBAAoB,CAAC,QAAwB;IAClD,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;IACnC,IAAI,WAAW,GAAG,CAAC,CAAC;IAEpB,sBAAsB;IACtB,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC;IACjG,MAAM,WAAW,GAAG,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IACrD,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,iBAAiB,IAAI,CAAC,CAAC,GAAG,WAAW,CAAC;IAE/D,8BAA8B;IAC9B,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,CAAC;IAChG,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,CAAC;IAChG,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,CAAC;IAChG,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,CAAC,GAAG,QAAQ,CAAC;IAEvE,yBAAyB;IACzB,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC;IAC3C,sBAAsB,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAC3D,sBAAsB,CAAC,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAE5D,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;AACzC,CAAC;AAED,SAAS,sBAAsB,CAAC,QAAwB;IACpD,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,GAAG,QAAQ,CAAC;IAE3D,QAAQ,kBAAkB,EAAE,CAAC;QACzB,KAAK,kBAAkB,CAAC,IAAI;YACxB,OAAO,iBAAiB,CAAC,cAAc,KAAK,SAAS;gBACjD,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,cAAc,CAAC;gBACzE,CAAC,CAAC,CAAC,CAAC;QACZ,KAAK,kBAAkB,CAAC,MAAM;YAC1B,OAAO,iBAAiB,CAAC,UAAU,KAAK,SAAS;gBAC7C,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,UAAU,CAAC;gBACjE,CAAC,CAAC,CAAC,CAAC;QACZ,KAAK,kBAAkB,CAAC,MAAM;YAC1B,OAAO,iBAAiB,CAAC,UAAU,KAAK,SAAS;gBAC7C,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,UAAU,CAAC;gBACjE,CAAC,CAAC,CAAC,CAAC;QACZ;YACI,OAAO,CAAC,CAAC;IACjB,CAAC;AACL,CAAC;AAED,SAAS,gBAAgB,CAAC,UAAkB;IACxC,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IACjC,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IACjC,sBAAsB,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACnD,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;AACzC,CAAC;AAED,SAAS,mBAAmB,CAAC,aAAwB;IACjD,MAAM,QAAQ,GAAmB;QAC7B,kBAAkB,EAAE,kBAAkB,CAAC,OAAO;QAC9C,iBAAiB,EAAE,IAAI,iBAAiB,CAAC,cAAc,CAAC,IAAI,CAAC;QAC7D,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,sBAAsB,CAAC,MAAM;QACrD,SAAS,EAAE,aAAa,CAAC,MAAM;QAC/B,UAAU,EAAE,CAAC;QACb,iBAAiB,EAAE,aAAa,CAAC,MAAM;KAC1C,CAAC;IACF,OAAO,kBAAkB,CAAC,QAAQ,EAAE,gBAAgB,CAAC,aAAa,CAAC,CAAC,CAAC;AACzE,CAAC;AAED,SAAS,kBAAkB,CAAC,aAAuB;IAC/C,MAAM,QAAQ,GAAmB;QAC7B,kBAAkB,EAAE,kBAAkB,CAAC,MAAM;QAC7C,iBAAiB,EAAE,IAAI,iBAAiB,CAAC,SAAS,EAAE,UAAU,CAAC,MAAM,CAAC;QACtE,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,qBAAqB,CAAC,IAAI;QAClD,sBAAsB,EAAE,sBAAsB,CAAC,MAAM;QACrD,SAAS,EAAE,aAAa,CAAC,MAAM;QAC/B,UAAU,EAAE,CAAC;QACb,iBAAiB,EAAE,aAAa,CAAC,MAAM;KAC1C,CAAC;IACF,OAAO,kBAAkB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,IAAI,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AAC1F,CAAC","sourcesContent":["import { PhysicalStreamType } from \"../metadata/tile/physicalStreamType\";\nimport { LogicalStreamType } from \"../metadata/tile/logicalStreamType\";\nimport { DictionaryType } from \"../metadata/tile/dictionaryType\";\nimport { LengthType } from \"../metadata/tile/lengthType\";\nimport { OffsetType } from \"../metadata/tile/offsetType\";\nimport { PhysicalLevelTechnique } from \"../metadata/tile/physicalLevelTechnique\";\nimport { LogicalLevelTechnique } from \"../metadata/tile/logicalLevelTechnique\";\nimport type { StreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport IntWrapper from \"../decoding/intWrapper\";\nimport { encodeBooleanRle, encodeStrings, createStringLengths, concatenateBuffers } from \"./encodingUtils\";\nimport { encodeVarintInt32Value, encodeVarintInt32 } from \"./integerEncodingUtils\";\n\n/**\n * Encodes plain strings into a complete stream with PRESENT (if needed), LENGTH, and DATA streams.\n * @param strings - Array of strings (can include null values)\n * @returns Encoded Uint8Array that can be passed to decodeString\n */\nexport function encodePlainStrings(strings: (string | null)[]): Uint8Array {\n    const hasNull = strings.some((s) => s === null);\n    const nonNullStrings = strings.filter((s): s is string => s !== null);\n    const stringBytes = encodeStrings(nonNullStrings);\n\n    const streams: Uint8Array[] = [];\n\n    // Add PRESENT stream if nulls exist\n    if (hasNull) {\n        const nullabilityValues = strings.map((s) => s !== null);\n        streams.push(\n            createStream(PhysicalStreamType.PRESENT, encodeBooleanRle(nullabilityValues), {\n                technique: PhysicalLevelTechnique.VARINT,\n                count: nullabilityValues.length,\n            }),\n        );\n    }\n\n    // Add LENGTH stream\n    const lengths = createStringLengths(nonNullStrings);\n    streams.push(\n        createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(new Int32Array(lengths)), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.VAR_BINARY),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: lengths.length,\n        }),\n    );\n\n    // Add DATA stream\n    streams.push(\n        createStream(PhysicalStreamType.DATA, stringBytes, {\n            logical: new LogicalStreamType(DictionaryType.NONE),\n        }),\n    );\n\n    return concatenateBuffers(...streams);\n}\n\n/**\n * Encodes dictionary-compressed strings into a complete stream.\n * @param strings - Array of strings (can include null values)\n * @returns Encoded Uint8Array that can be passed to decodeString\n */\nexport function encodeDictionaryStrings(strings: (string | null)[]): Uint8Array {\n    const hasNull = strings.some((s) => s === null);\n    const nonNullStrings = strings.filter((s): s is string => s !== null);\n\n    // Create dictionary of unique strings\n    const uniqueStrings = Array.from(new Set(nonNullStrings));\n    const stringMap = new Map(uniqueStrings.map((s, i) => [s, i]));\n    const offsets = nonNullStrings.map((s) => {\n        const offset = stringMap.get(s);\n        if (offset === undefined) {\n            throw new Error(`String not found in dictionary: ${s}`);\n        }\n        return offset;\n    });\n\n    const stringBytes = encodeStrings(uniqueStrings);\n    const lengths = createStringLengths(uniqueStrings);\n\n    const streams: Uint8Array[] = [];\n\n    // Add PRESENT stream if nulls exist\n    if (hasNull) {\n        const nullabilityValues = strings.map((s) => s !== null);\n        streams.push(\n            createStream(PhysicalStreamType.PRESENT, encodeBooleanRle(nullabilityValues), {\n                technique: PhysicalLevelTechnique.VARINT,\n                count: nullabilityValues.length,\n            }),\n        );\n    }\n\n    // Add OFFSET stream\n    streams.push(\n        createStream(PhysicalStreamType.OFFSET, encodeVarintInt32(new Int32Array(offsets)), {\n            logical: new LogicalStreamType(undefined, OffsetType.STRING),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: offsets.length,\n        }),\n    );\n\n    // Add LENGTH stream (for dictionary)\n    streams.push(\n        createStream(PhysicalStreamType.LENGTH, encodeVarintInt32(new Int32Array(lengths)), {\n            logical: new LogicalStreamType(undefined, undefined, LengthType.DICTIONARY),\n            technique: PhysicalLevelTechnique.VARINT,\n            count: lengths.length,\n        }),\n    );\n\n    // Add DATA stream\n    streams.push(\n        createStream(PhysicalStreamType.DATA, stringBytes, {\n            logical: new LogicalStreamType(DictionaryType.SINGLE),\n        }),\n    );\n\n    return concatenateBuffers(...streams);\n}\n\nfunction createStream(\n    physicalType: PhysicalStreamType,\n    data: Uint8Array,\n    options: {\n        logical?: LogicalStreamType;\n        technique?: PhysicalLevelTechnique;\n        count?: number;\n    } = {},\n): Uint8Array {\n    const count = options.count ?? 0;\n    return buildEncodedStream(\n        {\n            physicalStreamType: physicalType,\n            logicalStreamType: options.logical ?? new LogicalStreamType(),\n            logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n            logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n            physicalLevelTechnique: options.technique ?? PhysicalLevelTechnique.NONE,\n            numValues: count,\n            byteLength: data.length,\n            decompressedCount: count,\n        },\n        data,\n    );\n}\n\nfunction buildEncodedStream(streamMetadata: StreamMetadata, encodedData: Uint8Array): Uint8Array {\n    const updatedMetadata = {\n        ...streamMetadata,\n        byteLength: encodedData.length,\n    };\n\n    const metadataBuffer = encodeStreamMetadata(updatedMetadata);\n    const result = new Uint8Array(metadataBuffer.length + encodedData.length);\n    result.set(metadataBuffer, 0);\n    result.set(encodedData, metadataBuffer.length);\n\n    return result;\n}\n\nfunction encodeStreamMetadata(metadata: StreamMetadata): Uint8Array {\n    const buffer = new Uint8Array(100);\n    let writeOffset = 0;\n\n    // Byte 1: Stream type\n    const physicalTypeIndex = Object.values(PhysicalStreamType).indexOf(metadata.physicalStreamType);\n    const lowerNibble = getLogicalSubtypeValue(metadata);\n    buffer[writeOffset++] = (physicalTypeIndex << 4) | lowerNibble;\n\n    // Byte 2: Encoding techniques\n    const llt1Index = Object.values(LogicalLevelTechnique).indexOf(metadata.logicalLevelTechnique1);\n    const llt2Index = Object.values(LogicalLevelTechnique).indexOf(metadata.logicalLevelTechnique2);\n    const pltIndex = Object.values(PhysicalLevelTechnique).indexOf(metadata.physicalLevelTechnique);\n    buffer[writeOffset++] = (llt1Index << 5) | (llt2Index << 2) | pltIndex;\n\n    // Variable-length fields\n    const offset = new IntWrapper(writeOffset);\n    encodeVarintInt32Value(metadata.numValues, buffer, offset);\n    encodeVarintInt32Value(metadata.byteLength, buffer, offset);\n\n    return buffer.slice(0, offset.get());\n}\n\nfunction getLogicalSubtypeValue(metadata: StreamMetadata): number {\n    const { physicalStreamType, logicalStreamType } = metadata;\n\n    switch (physicalStreamType) {\n        case PhysicalStreamType.DATA:\n            return logicalStreamType.dictionaryType !== undefined\n                ? Object.values(DictionaryType).indexOf(logicalStreamType.dictionaryType)\n                : 0;\n        case PhysicalStreamType.OFFSET:\n            return logicalStreamType.offsetType !== undefined\n                ? Object.values(OffsetType).indexOf(logicalStreamType.offsetType)\n                : 0;\n        case PhysicalStreamType.LENGTH:\n            return logicalStreamType.lengthType !== undefined\n                ? Object.values(LengthType).indexOf(logicalStreamType.lengthType)\n                : 0;\n        default:\n            return 0;\n    }\n}\n\nfunction encodeNumStreams(numStreams: number): Uint8Array {\n    const buffer = new Uint8Array(5);\n    const offset = new IntWrapper(0);\n    encodeVarintInt32Value(numStreams, buffer, offset);\n    return buffer.slice(0, offset.get());\n}\n\nfunction createPresentStream(presentValues: boolean[]): Uint8Array {\n    const metadata: StreamMetadata = {\n        physicalStreamType: PhysicalStreamType.PRESENT,\n        logicalStreamType: new LogicalStreamType(DictionaryType.NONE),\n        logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n        logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues: presentValues.length,\n        byteLength: 0,\n        decompressedCount: presentValues.length,\n    };\n    return buildEncodedStream(metadata, encodeBooleanRle(presentValues));\n}\n\nfunction createOffsetStream(offsetIndices: number[]): Uint8Array {\n    const metadata: StreamMetadata = {\n        physicalStreamType: PhysicalStreamType.OFFSET,\n        logicalStreamType: new LogicalStreamType(undefined, OffsetType.STRING),\n        logicalLevelTechnique1: LogicalLevelTechnique.NONE,\n        logicalLevelTechnique2: LogicalLevelTechnique.NONE,\n        physicalLevelTechnique: PhysicalLevelTechnique.VARINT,\n        numValues: offsetIndices.length,\n        byteLength: 0,\n        decompressedCount: offsetIndices.length,\n    };\n    return buildEncodedStream(metadata, encodeVarintInt32(new Int32Array(offsetIndices)));\n}\n"]}