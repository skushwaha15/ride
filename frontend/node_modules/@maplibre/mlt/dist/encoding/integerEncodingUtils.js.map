{"version":3,"file":"integerEncodingUtils.js","sourceRoot":"","sources":["../../src/encoding/integerEncodingUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import IntWrapper from \"../decoding/intWrapper\";\n\nexport function encodeVarintInt32Value(value: number, dst: Uint8Array, offset: IntWrapper): void {\n    let v = value;\n    while (v > 0x7f) {\n        dst[offset.get()] = (v & 0x7f) | 0x80;\n        offset.increment();\n        v >>>= 7;\n    }\n    dst[offset.get()] = v & 0x7f;\n    offset.increment();\n}\n\nexport function encodeVarintInt32(values: Int32Array): Uint8Array {\n    const buffer = new Uint8Array(values.length * 5);\n    const offset = new IntWrapper(0);\n\n    for (const value of values) {\n        encodeVarintInt32Value(value, buffer, offset);\n    }\n    return buffer.slice(0, offset.get());\n}\n\nexport function encodeVarintInt64(values: BigInt64Array): Uint8Array {\n    const buffer = new Uint8Array(values.length * 10);\n    const offset = new IntWrapper(0);\n\n    for (const value of values) {\n        encodeVarintInt64Value(value, buffer, offset);\n    }\n    return buffer.slice(0, offset.get());\n}\n\nfunction encodeVarintInt64Value(value: bigint, dst: Uint8Array, offset: IntWrapper): void {\n    let v = value;\n    while (v > 0x7fn) {\n        dst[offset.get()] = Number(v & 0x7fn) | 0x80;\n        offset.increment();\n        v >>= 7n;\n    }\n    dst[offset.get()] = Number(v & 0x7fn);\n    offset.increment();\n}\n\nexport function encodeVarintFloat64(values: Float64Array): Uint8Array {\n    // 1. Calculate the exact size required for the buffer\n    let size = 0;\n    for (let i = 0; i < values.length; i++) {\n        let val = values[i];\n        // Ensure we handle the value as a positive integer\n        val = val < 0 ? 0 : Math.floor(val);\n\n        // 0 always takes 1 byte\n        if (val === 0) {\n            size++;\n            continue;\n        }\n\n        // Calculate bytes needed: ceil(log128(val + 1))\n        while (val > 0) {\n            size++;\n            val = Math.floor(val / 128);\n        }\n    }\n\n    const dst = new Uint8Array(size);\n    const offset = new IntWrapper(0);\n\n    for (let i = 0; i < values.length; i++) {\n        encodeVarintFloat64Value(values[i], dst, offset);\n    }\n\n    return dst;\n}\n\n/**\n * Encodes a single number into the buffer at the given offset using Varint encoding.\n * Handles numbers up to 2^53 (MAX_SAFE_INTEGER) correctly.\n */\nfunction encodeVarintFloat64Value(val: number, buf: Uint8Array, offset: IntWrapper): void {\n    // Ensure integer\n    val = Math.floor(val);\n\n    // Handle 0 explicitly or ensure loop runs once\n    if (val === 0) {\n        buf[offset.get()] = 0;\n        offset.increment();\n        return;\n    }\n\n    while (val >= 128) {\n        // Write 7 bits of data | 0x80 (continuation bit)\n        buf[offset.get()] = (val % 128) | 0x80;\n        offset.increment();\n        // Shift right by 7 bits\n        val = Math.floor(val / 128);\n    }\n\n    // Write the last byte (no continuation bit)\n    buf[offset.get()] = val;\n    offset.increment();\n}\n\nexport function encodeFastPfor(data: Int32Array): Uint8Array {\n    throw new Error(\"FastPFor is not implemented yet.\");\n}\n\nexport function encodeZigZagInt32Value(value: number): number {\n    return (value << 1) ^ (value >> 31);\n}\n\nexport function encodeZigZagInt64Value(value: bigint): bigint {\n    return (value << 1n) ^ (value >> 63n);\n}\n\nexport function encodeZigZagFloat64Value(n: number): number {\n    return n >= 0 ? n * 2 : n * -2 - 1;\n}\nexport function encodeZigZagInt32(data: Int32Array): void {\n    for (let i = 0; i < data.length; i++) {\n        data[i] = encodeZigZagInt32Value(data[i]);\n    }\n}\n\nexport function encodeZigZagInt64(data: BigInt64Array): void {\n    for (let i = 0; i < data.length; i++) {\n        data[i] = encodeZigZagInt64Value(data[i]);\n    }\n}\n\nexport function encodeZigZagFloat64(data: Float64Array): void {\n    for (let i = 0; i < data.length; i++) {\n        data[i] = encodeZigZagFloat64Value(data[i]);\n    }\n}\n\nexport function encodeUnsignedRleInt32(input: Int32Array): { data: Int32Array; runs: number } {\n    if (input.length === 0) {\n        return { data: new Int32Array(0), runs: 0 };\n    }\n\n    const runLengths: number[] = [];\n    const runValues: number[] = [];\n\n    let currentRunLength = 0;\n    let currentValue = input[0];\n\n    for (let i = 0; i < input.length; i++) {\n        const nextValue = input[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            // End of the current run, record it\n            runLengths.push(currentRunLength);\n            runValues.push(currentValue);\n\n            // Start a new run\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n\n    // Record the final run after the loop finishes\n    runLengths.push(currentRunLength);\n    runValues.push(currentValue);\n\n    // Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    const encodedData = new Int32Array(numRuns * 2);\n\n    // Populate the first half with lengths\n    encodedData.set(runLengths, 0);\n\n    // Populate the second half with values, offset by the total number of runs\n    encodedData.set(runValues, numRuns);\n\n    return { data: encodedData, runs: numRuns };\n}\n\nexport function encodeUnsignedRleInt64(input: BigInt64Array): { data: BigInt64Array; runs: number } {\n    if (input.length === 0) {\n        return { data: new BigInt64Array(0), runs: 0 };\n    }\n\n    const runLengths: number[] = [];\n    const runValues: bigint[] = [];\n\n    let currentRunLength = 0;\n    let currentValue: bigint = input[0];\n\n    for (let i = 0; i < input.length; i++) {\n        const nextValue = input[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            // End of the current run, record it\n            runLengths.push(currentRunLength);\n            runValues.push(currentValue);\n\n            // Start a new run\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n\n    // Record the final run after the loop finishes\n    runLengths.push(currentRunLength);\n    runValues.push(currentValue);\n\n    // Combine lengths and values into the final structured output array (BigInt64Array)\n    const numRuns = runLengths.length;\n    const encodedData = new BigInt64Array(numRuns * 2);\n\n    // Populate the first half with lengths. We must convert the numbers back to BigInts here.\n    for (let i = 0; i < numRuns; i++) {\n        encodedData[i] = BigInt(runLengths[i]);\n    }\n\n    // Populate the second half with values, offset by the total number of runs\n    encodedData.set(runValues, numRuns);\n\n    return { data: encodedData, runs: numRuns };\n}\n\nexport function encodeUnsignedRleFloat64(input: Float64Array): { data: Float64Array; runs: number } {\n    if (input.length === 0) {\n        return { data: new Float64Array(0), runs: 0 };\n    }\n\n    const runLengths: number[] = [];\n    const runValues: number[] = [];\n\n    let currentRunLength = 0;\n    let currentValue = input[0];\n\n    for (let i = 0; i < input.length; i++) {\n        const nextValue = input[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            // End of the current run, record it\n            runLengths.push(currentRunLength);\n            runValues.push(currentValue);\n\n            // Start a new run\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n\n    // Record the final run after the loop finishes\n    runLengths.push(currentRunLength);\n    runValues.push(currentValue);\n\n    // Combine lengths and values into the final structured output array (Float64Array)\n    const numRuns = runLengths.length;\n    // The final array is twice the size of the number of runs\n    const encodedData = new Float64Array(numRuns * 2);\n\n    // Populate the first half with lengths\n    encodedData.set(runLengths, 0);\n\n    // Populate the second half with values, offset by the total number of runs\n    encodedData.set(runValues, numRuns);\n\n    return { data: encodedData, runs: numRuns };\n}\n\nexport function encodeZigZagDeltaInt32(data: Int32Array): void {\n    if (data.length === 0) {\n        return;\n    }\n\n    let previousValue = data[0];\n    data[0] = encodeZigZagInt32Value(previousValue);\n\n    for (let i = 1; i < data.length; i++) {\n        const currentValue = data[i];\n        const delta = currentValue - previousValue;\n        const encodedDelta = encodeZigZagInt32Value(delta);\n\n        // Store the encoded delta back into the array\n        data[i] = encodedDelta;\n\n        // Update the previous value tracker for the next iteration's delta calculation\n        previousValue = currentValue;\n    }\n}\n\nexport function encodeZigZagDeltaInt64(data: BigInt64Array): void {\n    if (data.length === 0) {\n        return;\n    }\n\n    let previousValue = data[0];\n    data[0] = encodeZigZagInt64Value(previousValue);\n\n    for (let i = 1; i < data.length; i++) {\n        const currentValue = data[i];\n        const delta = currentValue - previousValue;\n        const encodedDelta = encodeZigZagInt64Value(delta);\n\n        // Store the encoded delta back into the array\n        data[i] = encodedDelta;\n\n        // Update the previous value tracker for the next iteration's delta calculation\n        previousValue = currentValue;\n    }\n}\n\nexport function encodeZigZagDeltaFloat64(data: Float64Array): void {\n    if (data.length === 0) {\n        return;\n    }\n\n    let previousValue = data[0];\n    data[0] = encodeZigZagFloat64Value(previousValue);\n\n    for (let i = 1; i < data.length; i++) {\n        const currentValue = data[i];\n        const delta = currentValue - previousValue;\n        const encodedDelta = encodeZigZagFloat64Value(delta);\n\n        // Store the encoded delta back into the array\n        data[i] = encodedDelta;\n\n        // Update the previous value tracker for the next iteration's delta calculation\n        previousValue = currentValue;\n    }\n}\n\nexport function encodeZigZagRleInt32(input: Int32Array): {\n    data: Int32Array;\n    runs: number;\n    numTotalValues: number;\n} {\n    if (input.length === 0) {\n        return { data: new Int32Array(0), runs: 0, numTotalValues: 0 };\n    }\n\n    const zigzagEncodedStream: number[] = [];\n\n    // Step 1: Apply Zigzag Encoding to all values\n    for (let i = 0; i < input.length; i++) {\n        zigzagEncodedStream.push(encodeZigZagInt32Value(input[i]));\n    }\n    // zigzagEncodedStream now holds the intermediate stream of zigzag values\n\n    // Step 2: Apply RLE to the stream of zigzag-encoded values\n    const runLengths: number[] = [];\n    const runZigZagValues: number[] = [];\n\n    let currentRunLength = 0;\n    let currentValue = zigzagEncodedStream[0];\n\n    for (let i = 0; i < zigzagEncodedStream.length; i++) {\n        const nextValue = zigzagEncodedStream[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            runLengths.push(currentRunLength);\n            runZigZagValues.push(currentValue);\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n    // Record the final run\n    runLengths.push(currentRunLength);\n    runZigZagValues.push(currentValue);\n\n    // Step 3: Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    // The final array uses Int32Array for lengths AND values\n    const encodedData = new Int32Array(numRuns * 2);\n\n    // Populate the first half with lengths\n    encodedData.set(runLengths, 0);\n\n    // Populate the second half with zigzagged values\n    encodedData.set(runZigZagValues, numRuns);\n\n    return {\n        data: encodedData,\n        runs: numRuns,\n        numTotalValues: input.length, // Total original values count\n    };\n}\n\nexport function encodeZigZagRleInt64(input: BigInt64Array): {\n    data: BigInt64Array;\n    runs: number;\n    numTotalValues: number;\n} {\n    if (input.length === 0) {\n        return { data: new BigInt64Array(0), runs: 0, numTotalValues: 0 };\n    }\n\n    const zigzagEncodedStream: bigint[] = [];\n\n    // Step 1: Apply Zigzag Encoding to all values\n    for (let i = 0; i < input.length; i++) {\n        zigzagEncodedStream.push(encodeZigZagInt64Value(input[i]));\n    }\n    // zigzagEncodedStream now holds the intermediate stream of zigzag values\n\n    // Step 2: Apply RLE to the stream of zigzag-encoded values\n    const runLengths: number[] = [];\n    const runZigZagValues: bigint[] = [];\n\n    let currentRunLength = 0;\n    let currentValue: bigint = zigzagEncodedStream[0];\n\n    for (let i = 0; i < zigzagEncodedStream.length; i++) {\n        const nextValue = zigzagEncodedStream[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            runLengths.push(currentRunLength);\n            runZigZagValues.push(currentValue);\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n    // Record the final run\n    runLengths.push(currentRunLength);\n    runZigZagValues.push(currentValue);\n\n    // Step 3: Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    // The final array uses BigInt64Array for lengths AND values\n    const encodedData = new BigInt64Array(numRuns * 2);\n\n    // Populate the first half with lengths (converting numbers back to BigInts)\n    for (let i = 0; i < numRuns; i++) {\n        encodedData[i] = BigInt(runLengths[i]);\n    }\n\n    // Populate the second half with zigzagged values\n    encodedData.set(runZigZagValues, numRuns);\n\n    return {\n        data: encodedData,\n        runs: numRuns,\n        numTotalValues: input.length, // Total original values count\n    };\n}\n\nexport function encodeZigZagRleFloat64(input: Float64Array): {\n    data: Float64Array;\n    runs: number;\n    numTotalValues: number;\n} {\n    if (input.length === 0) {\n        return { data: new Float64Array(0), runs: 0, numTotalValues: 0 };\n    }\n\n    const zigzagEncodedStream: number[] = [];\n\n    // Step 1: Apply Float-based Zigzag Encoding to all values\n    for (let i = 0; i < input.length; i++) {\n        zigzagEncodedStream.push(encodeZigZagFloat64Value(input[i]));\n    }\n    // zigzagEncodedStream now holds the intermediate stream of zigzag values (as floats acting as integers)\n\n    // Step 2: Apply RLE to the stream of zigzag-encoded values\n    const runLengths: number[] = [];\n    const runZigZagValues: number[] = [];\n\n    let currentRunLength = 0;\n    let currentValue = zigzagEncodedStream[0];\n\n    for (let i = 0; i < zigzagEncodedStream.length; i++) {\n        const nextValue = zigzagEncodedStream[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            runLengths.push(currentRunLength);\n            runZigZagValues.push(currentValue);\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n    // Record the final run\n    runLengths.push(currentRunLength);\n    runZigZagValues.push(currentValue);\n\n    // Step 3: Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    // The final array uses Float64Array for lengths AND values\n    const encodedData = new Float64Array(numRuns * 2);\n\n    // Populate the first half with lengths\n    encodedData.set(runLengths, 0);\n\n    // Populate the second half with zigzagged values\n    encodedData.set(runZigZagValues, numRuns);\n\n    return {\n        data: encodedData,\n        runs: numRuns,\n        numTotalValues: input.length, // Total original values count\n    };\n}\n\n/**\n * This is not really a encode, but more of a decode method...\n */\nexport function encodeDeltaInt32(data: Int32Array): void {\n    if (data.length === 0) {\n        return;\n    }\n    for (let i = data.length - 1; i >= 1; i--) {\n        data[i] = data[i] - data[i - 1];\n    }\n}\n\nexport function encodeComponentwiseDeltaVec2(data: Int32Array): void {\n    if (data.length < 2) return;\n\n    // Reverse iterate to avoid overwriting data needed for delta computation\n    for (let i = data.length - 2; i >= 2; i -= 2) {\n        const deltaX = data[i] - data[i - 2];\n        const deltaY = data[i + 1] - data[i - 1];\n        data[i] = encodeZigZagInt32Value(deltaX);\n        data[i + 1] = encodeZigZagInt32Value(deltaY);\n    }\n\n    // Encode first vertex last (after computing all deltas)\n    data[0] = encodeZigZagInt32Value(data[0]);\n    data[1] = encodeZigZagInt32Value(data[1]);\n}\n\nexport function encodeComponentwiseDeltaVec2Scaled(data: Int32Array, scale: number): void {\n    if (data.length < 2) return;\n\n    // First, inverse scale all values (tile space -> original space)\n    for (let i = 0; i < data.length; i++) {\n        data[i] = Math.round(data[i] / scale);\n    }\n\n    // Then apply componentwise delta encoding (same as non-scaled version)\n    // Reverse iterate to avoid overwriting data needed for delta computation\n    for (let i = data.length - 2; i >= 2; i -= 2) {\n        const deltaX = data[i] - data[i - 2];\n        const deltaY = data[i + 1] - data[i - 1];\n        data[i] = encodeZigZagInt32Value(deltaX);\n        data[i + 1] = encodeZigZagInt32Value(deltaY);\n    }\n\n    // Encode first vertex last (after computing all deltas)\n    data[0] = encodeZigZagInt32Value(data[0]);\n    data[1] = encodeZigZagInt32Value(data[1]);\n}\n\n// HM TODO:\n// zigZagDeltaOfDeltaDecoding\n\nexport function encodeZigZagRleDeltaInt32(values: Int32Array | number[]): {\n    data: Int32Array;\n    runs: number;\n    numTotalValues: number;\n} {\n    if (values.length === 0) {\n        return { data: new Int32Array(0), runs: 0, numTotalValues: 0 };\n    }\n\n    const runLengths: number[] = [];\n    const encodedDeltas: number[] = [];\n\n    // The decoder explicitly sets decodedValues[0] = 0 and uses previousValue = 0.\n    // Therefore, we initialize our 'previous' tracker to 0 to calculate the first delta correctly.\n    let previousValue = 0;\n\n    // Variables to track the current run\n    let currentDelta: number | null = null;\n    let currentRunLength = 0;\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        const delta = value - previousValue;\n        previousValue = value;\n\n        if (currentDelta === null) {\n            // First element initialization\n            currentDelta = delta;\n            currentRunLength = 1;\n        } else if (delta === currentDelta) {\n            // Continuation of the current run\n            currentRunLength++;\n        } else {\n            // The run has broken (delta changed)\n            // 1. Push the length of the previous run\n            runLengths.push(currentRunLength);\n            // 2. ZigZag encode the previous delta and push it\n            encodedDeltas.push(encodeZigZagInt32Value(currentDelta));\n\n            // Start the new run\n            currentDelta = delta;\n            currentRunLength = 1;\n        }\n    }\n\n    // Flush the final run remaining after the loop finishes\n    if (currentDelta !== null) {\n        runLengths.push(currentRunLength);\n        encodedDeltas.push(encodeZigZagInt32Value(currentDelta));\n    }\n\n    const numRuns = runLengths.length;\n\n    // The decoder expects 'data' to be: [RunLength 1, RunLength 2... | Value 1, Value 2...]\n    // Size is numRuns * 2 (First half lengths, second half values)\n    const data = new Int32Array(numRuns * 2);\n\n    for (let i = 0; i < numRuns; i++) {\n        data[i] = runLengths[i]; // First half: Run Lengths\n        data[i + numRuns] = encodedDeltas[i]; // Second half: ZigZag Encoded Deltas\n    }\n\n    return {\n        data: data,\n        runs: numRuns,\n        numTotalValues: values.length,\n    };\n}\n\nexport function encodeRleDeltaInt32(values: Int32Array | number[]): {\n    data: Int32Array;\n    runs: number;\n    numTotalValues: number;\n} {\n    if (values.length === 0) {\n        return { data: new Int32Array(0), runs: 0, numTotalValues: 0 };\n    }\n\n    const runLengths: number[] = [];\n    const deltas: number[] = [];\n\n    // The decoder logic relies on: decodedValues[0] = 0; previousValue = 0;\n    // So the encoder must assume the sequence starts relative to 0.\n    let previousValue = 0;\n\n    // Track the current run of deltas\n    let currentDelta: number | null = null;\n    let currentRunLength = 0;\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        const delta = value - previousValue;\n        previousValue = value;\n\n        if (currentDelta === null) {\n            // Initialize first run\n            currentDelta = delta;\n            currentRunLength = 1;\n        } else if (delta === currentDelta) {\n            // Continue current run\n            currentRunLength++;\n        } else {\n            // Delta changed: flush the previous run\n            runLengths.push(currentRunLength);\n            deltas.push(currentDelta);\n\n            // Start new run\n            currentDelta = delta;\n            currentRunLength = 1;\n        }\n    }\n\n    // Flush the final run\n    if (currentDelta !== null) {\n        runLengths.push(currentRunLength);\n        deltas.push(currentDelta);\n    }\n\n    const numRuns = runLengths.length;\n\n    // Pack into Int32Array: [ RunLength 1...N | Delta 1...N ]\n    const data = new Int32Array(numRuns * 2);\n    for (let i = 0; i < numRuns; i++) {\n        data[i] = runLengths[i];\n        data[i + numRuns] = deltas[i];\n    }\n\n    return {\n        data: data,\n        runs: numRuns,\n        numTotalValues: values.length,\n    };\n}\n\nexport function encodeDeltaRleInt32(input: Int32Array): {\n    data: Int32Array;\n    runs: number;\n    numValues: number;\n} {\n    if (input.length === 0) {\n        return { data: new Int32Array(0), runs: 0, numValues: 0 };\n    }\n\n    const deltasAndEncoded: number[] = [];\n    let previousValue: number = 0;\n\n    // Step 1 & 2: Calculate Deltas and Zigzag Encode them\n    for (let i = 0; i < input.length; i++) {\n        const currentValue = input[i];\n        const delta = currentValue - previousValue;\n        const encodedDelta = encodeZigZagInt32Value(delta);\n        deltasAndEncoded.push(encodedDelta);\n        previousValue = currentValue;\n    }\n    // deltasAndEncoded now holds the intermediate stream of zigzagged deltas\n\n    // Step 3: Apply RLE to the stream of zigzag-encoded deltas\n    const runLengths: number[] = [];\n    const runZigZagDeltas: number[] = [];\n\n    let currentRunLength = 0;\n    let currentRunValue = deltasAndEncoded[0];\n\n    for (let i = 0; i < deltasAndEncoded.length; i++) {\n        const nextValue = deltasAndEncoded[i];\n\n        if (nextValue === currentRunValue) {\n            currentRunLength++;\n        } else {\n            runLengths.push(currentRunLength);\n            runZigZagDeltas.push(currentRunValue);\n            currentRunValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n    // Record the final run\n    runLengths.push(currentRunLength);\n    runZigZagDeltas.push(currentRunValue);\n\n    // Step 4: Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    const encodedData = new Int32Array(numRuns * 2);\n\n    // Populate the first half with lengths\n    for (let i = 0; i < numRuns; i++) {\n        encodedData[i] = runLengths[i];\n    }\n\n    // Populate the second half with zigzagged deltas\n    // Int32Array.set() works with standard number arrays\n    encodedData.set(runZigZagDeltas, numRuns);\n\n    return {\n        data: encodedData,\n        runs: numRuns,\n        numValues: input.length, // Total original values count\n    };\n}\n\nexport function encodeDeltaRleInt64(input: BigInt64Array): {\n    data: BigInt64Array;\n    runs: number;\n    numValues: number;\n} {\n    if (input.length === 0) {\n        return { data: new BigInt64Array(0), runs: 0, numValues: 0 };\n    }\n\n    const deltasAndEncoded: bigint[] = [];\n    let previousValue: bigint = 0n;\n\n    // Step 1 & 2: Calculate Deltas and Zigzag Encode them\n    for (let i = 0; i < input.length; i++) {\n        const currentValue = input[i];\n        const delta = currentValue - previousValue;\n        const encodedDelta = encodeZigZagInt64Value(delta);\n        deltasAndEncoded.push(encodedDelta);\n        previousValue = currentValue;\n    }\n    // deltasAndEncoded now holds the intermediate stream of zigzagged deltas\n\n    // Step 3: Apply RLE to the stream of zigzag-encoded deltas\n    const runLengths: number[] = [];\n    const runZigZagDeltas: bigint[] = [];\n\n    let currentRunLength = 0;\n    let currentValue = deltasAndEncoded[0];\n\n    for (let i = 0; i < deltasAndEncoded.length; i++) {\n        const nextValue = deltasAndEncoded[i];\n\n        if (nextValue === currentValue) {\n            currentRunLength++;\n        } else {\n            runLengths.push(currentRunLength);\n            runZigZagDeltas.push(currentValue);\n            currentValue = nextValue;\n            currentRunLength = 1;\n        }\n    }\n    // Record the final run\n    runLengths.push(currentRunLength);\n    runZigZagDeltas.push(currentValue);\n\n    // Step 4: Combine lengths and values into the final structured output array\n    const numRuns = runLengths.length;\n    const encodedData = new BigInt64Array(numRuns * 2);\n\n    // Populate the first half with lengths (converting numbers back to BigInts for storage)\n    for (let i = 0; i < numRuns; i++) {\n        encodedData[i] = BigInt(runLengths[i]);\n    }\n\n    // Populate the second half with zigzagged deltas\n    encodedData.set(runZigZagDeltas, numRuns);\n\n    return {\n        data: encodedData,\n        runs: numRuns,\n        numValues: input.length, // Total original values count\n    };\n}\n"]}