{"version":3,"file":"fsstEncoder.js","sourceRoot":"","sources":["../../src/encoding/fsstEncoder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Create symbol table from string array\n *\n * @param symbolStrings     Array of symbol strings\n * @returns                 Symbol table buffer and lengths\n */\nexport function createSymbolTable(symbolStrings: string[]): { symbols: Uint8Array; symbolLengths: Uint32Array } {\n    const textEncoder = new TextEncoder();\n    const symbolBuffers = symbolStrings.map((s) => textEncoder.encode(s));\n    const symbolLengths = new Uint32Array(symbolBuffers.map((b) => b.length));\n    const totalLength = symbolBuffers.reduce((sum, b) => sum + b.length, 0);\n    const symbols = new Uint8Array(totalLength);\n\n    let offset = 0;\n    for (const buffer of symbolBuffers) {\n        symbols.set(buffer, offset);\n        offset += buffer.length;\n    }\n\n    return { symbols, symbolLengths };\n}\n\n/**\n * Encode data using FSST compression with pre-defined symbol table\n * Encoder requires pre-defined symbol table. Real FSST learns optimal symbols from data. This\n * implementation is for testing decoder only.\n *\n * @param symbols           Array of symbols, where each symbol can be between 1 and 8 bytes\n * @param symbolLengths     Array of symbol lengths, length of each symbol in symbols array\n * @param uncompressedData  Data to compress\n * @returns                 FSST compressed data, where each entry is an index to the symbols array\n */\nexport function encodeFsst(symbols: Uint8Array, symbolLengths: Uint32Array, uncompressedData: Uint8Array): Uint8Array {\n    if (uncompressedData.length === 0) {\n        return new Uint8Array(0);\n    }\n\n    // Calculate symbol offsets (cumulative sum of lengths)\n    const symbolOffsets: number[] = new Array(symbolLengths.length).fill(0);\n    for (let i = 1; i < symbolLengths.length; i++) {\n        symbolOffsets[i] = symbolOffsets[i - 1] + symbolLengths[i - 1];\n    }\n\n    const result: number[] = [];\n    let pos = 0;\n\n    while (pos < uncompressedData.length) {\n        let bestSymbolIndex = -1;\n        let bestSymbolLength = 0;\n\n        // Try to find longest matching symbol at current position\n        for (let symbolIndex = 0; symbolIndex < symbolLengths.length; symbolIndex++) {\n            const symbolLength = symbolLengths[symbolIndex];\n            const symbolOffset = symbolOffsets[symbolIndex];\n\n            // Check if symbol could fit and is longer than current best\n            if (pos + symbolLength <= uncompressedData.length && symbolLength > bestSymbolLength) {\n                // Check if bytes match\n                let matches = true;\n                for (let i = 0; i < symbolLength; i++) {\n                    if (symbols[symbolOffset + i] !== uncompressedData[pos + i]) {\n                        matches = false;\n                        break;\n                    }\n                }\n\n                if (matches) {\n                    bestSymbolIndex = symbolIndex;\n                    bestSymbolLength = symbolLength;\n                }\n            }\n        }\n\n        if (bestSymbolIndex !== -1) {\n            // Found a matching symbol\n            result.push(bestSymbolIndex);\n            pos += bestSymbolLength;\n        } else {\n            // No match - emit escape sequence (255 followed by literal byte)\n            result.push(255);\n            result.push(uncompressedData[pos]);\n            pos++;\n        }\n    }\n\n    return new Uint8Array(result);\n}\n"]}