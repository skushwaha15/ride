{"version":3,"file":"integerStreamEncoder.js","sourceRoot":"","sources":["../../src/encoding/integerStreamEncoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { type StreamMetadata } from \"../metadata/tile/streamMetadataDecoder\";\nimport { LogicalLevelTechnique } from \"../metadata/tile/logicalLevelTechnique\";\nimport {\n    encodeDeltaRleInt32,\n    encodeZigZagInt32,\n    encodeZigZagRleInt32,\n    encodeUnsignedRleInt32,\n    encodeDeltaInt32,\n    encodeUnsignedRleFloat64,\n    encodeZigZagDeltaFloat64,\n    encodeZigZagFloat64,\n    encodeZigZagRleFloat64,\n    encodeVarintInt32,\n    encodeVarintInt64,\n    encodeZigZagInt64Value,\n    encodeFastPfor,\n    encodeComponentwiseDeltaVec2,\n    encodeComponentwiseDeltaVec2Scaled,\n} from \"./integerEncodingUtils\";\nimport type BitVector from \"../vector/flat/bitVector\";\nimport { packNullable } from \"./packNullableUtils\";\nimport { PhysicalLevelTechnique } from \"../metadata/tile/physicalLevelTechnique\";\nimport type GeometryScaling from \"../decoding/geometryScaling\";\n\nexport function encodeIntStream(\n    values: Int32Array,\n    metadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector?: BitVector,\n    scalingData?: GeometryScaling,\n): Uint8Array {\n    const { data } = encodeInt32(values, metadata, isSigned, bitVector, scalingData);\n    return encodePhysicalLevelTechnique(data, metadata);\n}\n\nfunction encodePhysicalLevelTechnique(data: Int32Array, streamMetadata: StreamMetadata): Uint8Array {\n    const physicalLevelTechnique = streamMetadata.physicalLevelTechnique;\n    if (physicalLevelTechnique === PhysicalLevelTechnique.FAST_PFOR) {\n        return encodeFastPfor(data);\n    }\n    if (physicalLevelTechnique === PhysicalLevelTechnique.VARINT) {\n        return encodeVarintInt32(data);\n    }\n\n    if (physicalLevelTechnique === PhysicalLevelTechnique.NONE) {\n        const slice = data.subarray(0, streamMetadata.byteLength);\n        return new Uint8Array(slice);\n    }\n\n    throw new Error(\"Specified physicalLevelTechnique is not supported (yet).\");\n}\n\nfunction encodeInt32(\n    values: Int32Array,\n    streamMetadata: StreamMetadata,\n    isSigned: boolean,\n    bitVector?: BitVector,\n    scalingData?: GeometryScaling,\n): { data: Int32Array; runs?: number } {\n    const data = bitVector ? packNullable(values, bitVector) : new Int32Array(values);\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                const encoded = encodeDeltaRleInt32(data);\n                return { data: encoded.data, runs: encoded.runs };\n            }\n            encodeDeltaInt32(data);\n            encodeZigZagInt32(data);\n            return { data };\n        case LogicalLevelTechnique.RLE: {\n            if (isSigned) {\n                const encoded = encodeZigZagRleInt32(data);\n                return { data: encoded.data, runs: encoded.runs };\n            }\n            const encoded = encodeUnsignedRleInt32(data);\n            return { data: encoded.data, runs: encoded.runs };\n        }\n        case LogicalLevelTechnique.MORTON:\n            encodeDeltaInt32(data);\n            return { data };\n        case LogicalLevelTechnique.COMPONENTWISE_DELTA:\n            if (scalingData && !bitVector) {\n                encodeComponentwiseDeltaVec2Scaled(data, scalingData.scale);\n                return { data };\n            }\n            encodeComponentwiseDeltaVec2(data);\n            return { data };\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                encodeZigZagInt32(data);\n            }\n            return { data };\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nexport function encodeFloat64(values: Float64Array, streamMetadata: StreamMetadata, isSigned: boolean): Float64Array {\n    switch (streamMetadata.logicalLevelTechnique1) {\n        case LogicalLevelTechnique.DELTA:\n            encodeZigZagDeltaFloat64(values);\n            if (streamMetadata.logicalLevelTechnique2 === LogicalLevelTechnique.RLE) {\n                values = encodeUnsignedRleFloat64(values).data;\n            }\n            return values;\n        case LogicalLevelTechnique.RLE:\n            return encodeRleFloat64(values, isSigned);\n        case LogicalLevelTechnique.NONE:\n            if (isSigned) {\n                encodeZigZagFloat64(values);\n            }\n            return values;\n        default:\n            throw new Error(\n                `The specified Logical level technique is not supported: ${streamMetadata.logicalLevelTechnique1}`,\n            );\n    }\n}\n\nfunction encodeRleFloat64(data: Float64Array, isSigned: boolean): Float64Array {\n    return isSigned ? encodeZigZagRleFloat64(data).data : encodeUnsignedRleFloat64(data).data;\n}\n\n/**\n * Encodes BigInt64 values with zigzag encoding and varint compression\n */\nexport function encodeInt64SignedNone(values: BigInt64Array): Uint8Array {\n    const zigzagEncoded = new BigInt64Array(Array.from(values, (val) => encodeZigZagInt64Value(val)));\n    return encodeVarintInt64(zigzagEncoded);\n}\n\n/**\n * Encodes BigInt64 values with delta encoding, zigzag, and varint\n */\nexport function encodeInt64SignedDelta(values: BigInt64Array): Uint8Array {\n    const deltaEncoded = new BigInt64Array(values.length);\n    deltaEncoded[0] = values[0];\n    for (let i = 1; i < values.length; i++) {\n        deltaEncoded[i] = values[i] - values[i - 1];\n    }\n    const zigzagEncoded = new BigInt64Array(deltaEncoded.length);\n    for (let i = 0; i < deltaEncoded.length; i++) {\n        zigzagEncoded[i] = encodeZigZagInt64Value(deltaEncoded[i]);\n    }\n    return encodeVarintInt64(zigzagEncoded);\n}\n\n/**\n * Encodes BigInt64 values with RLE, zigzag, and varint\n * @param runs - Array of [runLength, value] pairs\n */\nexport function encodeInt64SignedRle(runs: Array<[number, bigint]>): Uint8Array {\n    const runLengths: bigint[] = [];\n    const values: bigint[] = [];\n\n    for (const [runLength, value] of runs) {\n        runLengths.push(BigInt(runLength));\n        values.push(encodeZigZagInt64Value(value));\n    }\n\n    const rleValues = [...runLengths, ...values];\n    return encodeVarintInt64(new BigInt64Array(rleValues));\n}\n\n/**\n * Encodes BigInt64 values with delta+RLE, zigzag, and varint\n * @param runs - Array of [runLength, deltaValue] pairs representing RLE-encoded delta values\n */\nexport function encodeInt64SignedDeltaRle(runs: Array<[number, bigint]>): Uint8Array {\n    const runLengths: bigint[] = [];\n    const values: bigint[] = [];\n\n    for (const [runLength, value] of runs) {\n        runLengths.push(BigInt(runLength));\n        values.push(encodeZigZagInt64Value(value));\n    }\n\n    const rleValues = [...runLengths, ...values];\n    return encodeVarintInt64(new BigInt64Array(rleValues));\n}\n\n/**\n * Encodes unsigned BigInt64 values with varint compression (no zigzag)\n */\nexport function encodeInt64UnsignedNone(values: BigInt64Array): Uint8Array {\n    return encodeVarintInt64(values);\n}\n"]}